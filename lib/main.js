// Generated by CoffeeScript 1.7.1

/**
 Gamepad unify interface for browsrs. 
 Interface write in README.md
 Original language is russian.
 
 Унифицированный интерфейс для использования игрового джойстика.
 Документация описана в README.md
 Игровой дойстик может быть использован, как событийно, так и по опросам состояний.
 Для удобства создания альтеонативных, расширенных и дополненных карт кнопок в 
 глобальной области видимости определён GamepadMap.
 Для работы с экземпляром джойстика напрямую, определён Gamepad2.
 Для работы с массивом джойстиков, получения событий подключения и отключения джойстиков
 определён Gamepads.
 При работе с джойстиками рекомендуется использовать Gamepads, т.к. многие детали 
 обработки событий, подключения и переподключения джойстиков разрешены исключително
 в данном классе. Советуется так же исползовать один экземпляр класса, но возможно 
 и несколько экземпляров, с той оговоркой, что тихий режим определяется последним 
 созданным экземпляром.
 
 @author Sergey Shilov
 @license GPL v2
 @preserve Продукт предоставляется, как есть, без гарантий, со всеми исходными 
 кодами и ссылками на библиотеки, используемыми для компиляции. Разрешается испоьзования
 без разрешения автора только в продуктах без коммерческой составляющей, за исключением
 продуктов исключительно со свободными пожертвованиями и продуктов со свободной ценой. 
 В противном случае необходимо разрешение автора в письменном бумажном или электронном 
 виде для конкретного продукта.
 */

(function() {
  "use strict";

  /*
    naming variables:
    gamepad and gamepadX instance of Gamepad (by browser)
    pad and padX instance of Gamepad2 (local)
   */
  var Axis, Block, Button, EventTargetEmiter, EventedArray, Gamepad2, GamepadMap, Gamepads, SPoke, isFunction, isString, merge, messages, overlay, silent, skip, start, stopTick, throwError, throwInfo, throwWarn, tick, top, wait, zeroFill, _implements,
    __slice = [].slice,
    __hasProp = {}.hasOwnProperty,
    __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
    __indexOf = [].indexOf || function(item) { for (var i = 0, l = this.length; i < l; i++) { if (i in this && this[i] === item) return i; } return -1; };

  _implements = function() {
    var key, mixin, mixins, value, _i, _len, _ref;
    mixins = 1 <= arguments.length ? __slice.call(arguments, 0) : [];
    for (_i = 0, _len = mixins.length; _i < _len; _i++) {
      mixin = mixins[_i];
      _ref = mixin.prototype;
      for (key in _ref) {
        value = _ref[key];
        this.prototype[key] = value;
      }
    }
    return this;
  };


  /**
    * накладывает объект `from` на объект `to`<br />
    * если нужно создать третий объект (не трогать `to`) из двух надо использовать `merge(merge({}, to), from)` <br />
    * (!) Нет защиты от дурака. Если аргументы не объекты, то результат не предсказуем и может быть ошибка.
    *
    * @param {Object|Array} to модифицируемый объект
    * @param {Object|Array} from модифицирующий объект
    * @return {Object} изменённый `to`
   */

  merge = function(to, from) {
    var e, p;
    if (!((to != null) || typeof to !== 'object')) {
      return from;
    }
    for (p in from) {
      if (!__hasProp.call(from, p)) continue;
      try {
        if ((from[p] != null) && typeof from[p] === 'object') {
          to[p] = merge(to[p], from[p]);
        } else {
          to[p] = from[p];
        }
      } catch (_error) {
        e = _error;
        to[p] = merge({}, from[p]);
      }
    }
    return to;
  };


  /**
    * merge under with upper, but create new object, don't touch under or upper.
    *
    * @method overlay
    * @param {Object|Array} under basic object
    * @param {Object|Array} upper object width modification
    * @return {Object} new object
   */

  overlay = function(under, upper) {
    return merge(merge({}, under), upper);
  };


  /**
    Режим без вывода ошибок, предупреждений и сообщений в консоль. Учитывается без DEBUG,
    определяется в конструкторе Gamepads.
    @type Boolean
   */

  silent = true;

  messages = {
    error: [],
    warn: [],
    info: []
  };


  /**
    константа для меток времени относительно старта скрипта в массиве сообщений
    @type Timestamp
   */

  start = Date.now();


  /** 
    Добавляет сообщения в массив, прикрепляя метку времени. 
    Если не тихий режим, выводит в консоль.
    @param * errors ошибки
   */

  throwError = function() {
    var errors, out;
    errors = 1 <= arguments.length ? __slice.call(arguments, 0) : [];
    out = [Date.now() - start];
    out.push.apply(out, errors);
    messages.error.push(out);
    if (!silent) {
      console.error.apply(console, errors);
    }
  };


  /**
    @param * warn предупреждения
   */

  throwWarn = function() {
    var out, warn;
    warn = 1 <= arguments.length ? __slice.call(arguments, 0) : [];
    out = [Date.now() - start];
    out.push.apply(out, warn);
    messages.warn.push(out);
    if (!silent) {
      console.warn.apply(console, warn);
    }
  };


  /**
    @param * info сообщения
   */

  throwInfo = function() {
    var info, out;
    info = 1 <= arguments.length ? __slice.call(arguments, 0) : [];
    out = [Date.now() - start];
    out.push.apply(out, info);
    messages.info.push(out);
    if (!silent) {
      console.info.apply(console, info);
    }
  };


  /**
    Check `functionToCheck` function handle or not?
    @param handle|* functionToCheck
    @retoorn Boolean
   */

  isFunction = function(functionToCheck) {
    var getType;
    getType = {};
    return functionToCheck && getType.toString.call(functionToCheck) === "[object Function]";
  };


  /**
    Check `string` is string.
    @param String|* string
    @retoorn Boolean
   */

  isString = function(string) {
    return string + '' === string;
  };


  /**
    Create from `number` string length `width` width '0' before `number`.
    If `number` length above than `width`, return `number` as string.
    @param String|Number number
    @param Number width
    @return String
   */

  zeroFill = function(number, width) {
    width -= number.toString().length;
    if (width > 0) {
      return new Array(width + 1).join("0") + number;
    }
    return number + "";
  };

  wait = function(time, fn) {
    return setTimeout(fn, time);
  };

  skip = function(waitId) {
    return clearTimeout(waitId);
  };

  tick = function(time, fn) {
    return setInterval(fn, time);
  };

  stopTick = function(tickId) {
    return clearInterval(tickId);
  };


  /**
   * EventTargetEmmiter emulate EventTarget interface width Emiter methods on, off, emet
   * Интерфейс EventTarget полностью воплощён в соответствии со стандартом w3c:
   * http://www.w3.org/TR/domcore/#interface-eventtarget
   * @class EventTargetEmiter
   */

  EventTargetEmiter = (function() {

    /**
     * Список подпсок на события по названию в виде массива.
     * @protected
     * @type Object
     */
    EventTargetEmiter.prototype._subscribe = null;


    /**
     * Проверяет правильность создаваемого обработчика события.
     * @protected
     * @method _checkValues
     * @param String|* type имя события
     * @param Handler|* listener  функция-обработчик
     */

    EventTargetEmiter.prototype._checkValues = function(type, listener) {
      if (!isString(type)) {
        throwError("type not string");
        return false;
      }
      if (!isFunction(listener)) {
        throwError("listener is not a function");
        return false;
      }
      return true;
    };


    /**
     * Перечисленные в `list` события декларируют события и создат традиционные 
     * handler-обработчики
     * @constructor
     * @param Array list названия событий
     */

    function EventTargetEmiter() {
      var e, list, _i, _len;
      list = 1 <= arguments.length ? __slice.call(arguments, 0) : [];
      this._subscribe = {
        _length: 0
      };
      for (_i = 0, _len = list.length; _i < _len; _i++) {
        e = list[_i];
        this._subscribe[e] = [];
        this['on' + e] = null;
      }
    }


    /**
     * Add function `listener` by `type` with `useCapture`
     * @public
     * @method addEventListener
     * @param String type
     * @param Handler listener
     * @param Boolean useCapture = false
     * @return void
     */

    EventTargetEmiter.prototype.addEventListener = function(type, listener, useCapture) {
      if (useCapture == null) {
        useCapture = false;
      }
      if (!this._checkValues(type, listener)) {
        return;
      }
      useCapture = !!useCapture;
      this._subscribe[type].push([listener, useCapture]);
      this._subscribe._length++;
    };


    /**
     * Remove function `listener` by `type` with `useCapture`
     * @public
     * @method removeEventListener
     * @param String type 
     * @param Handler listener
     * @param Boolean useCapture = false
     */

    EventTargetEmiter.prototype.removeEventListener = function(type, listener, useCapture) {
      var fn, i, _i, _len, _ref;
      if (useCapture == null) {
        useCapture = false;
      }
      if (!this._checkValues(type, listener)) {
        return;
      }
      useCapture = !!useCapture;
      if (this._subscribe[type] == null) {
        return;
      }
      _ref = this._subscribe[type];
      for (i = _i = 0, _len = _ref.length; _i < _len; i = ++_i) {
        fn = _ref[i];
        if (fn[0] === listener && fn[1] === useCapture) {
          this._subscribe[type].splice(i, 1);
          this._subscribe._length--;
          return;
        }
      }
    };


    /**
     * Burn, baby, burn!
     * @public
     * @method dispatchEvent
     * @param Event evt
     * @return Boolean
     */

    EventTargetEmiter.prototype.dispatchEvent = function(evt) {
      var t;
      if (!(evt instanceof Event)) {
        throwError("evt is not event.");
        return false;
      }
      t = evt.type;
      if (this._subscribe[t] == null) {
        throw new EventException("UNSPECIFIED_EVENT_TYPE_ERR");
        return false;
      }
      return this.emet(t, evt);
    };


    /**
     * Alias for addEventListener
     * @public
     * @method on
     * @param String type
     * @param Handler listener
     * @param Boolean useCapture
     * @return void
     */

    EventTargetEmiter.prototype.on = EventTargetEmiter.prototype.addEventListener;


    /**
     * Alias for removeEventListener
     * @public
     * @method off
     * @param String type
     * @param Handler listener
     * @param Boolean useCapture
     * @return void
     */

    EventTargetEmiter.prototype.off = EventTargetEmiter.prototype.removeEventListener;


    /**
     * Emiter event by `name` and create event or use `evt` if exist
     * @param String name
     * @param Event|null evt
     * @return Boolean
     */

    EventTargetEmiter.prototype.emet = function(name, evt) {
      var fn, r, _i, _len, _ref;
      if (evt == null) {
        evt = null;
      }
      if (isFunction(this['on' + name])) {
        r = this['on' + name](evt);
      }
      if (r === false) {
        return false;
      }
      _ref = this._subscribe[name];
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        fn = _ref[_i];
        try {
          r = fn[0](evt);
        } catch (_error) {}
        if (fn[1] === true || r === false) {
          break;
        }
      }
      if (evt != null) {
        return !evt.defaultPrevented;
      } else {
        return true;
      }
    };

    return EventTargetEmiter;

  })();


  /**
   * Массив с возможностью создания и получения событий.
   * @class EventedArray
   * @extends Array
   * @implements EventTargetEmiter
   */

  EventedArray = (function(_super) {
    __extends(EventedArray, _super);

    _implements.call(EventedArray, EventTargetEmiter);


    /**
     * @constructor
     * @param items array-style constructor without single item as length.
     */

    function EventedArray() {
      var items;
      items = 1 <= arguments.length ? __slice.call(arguments, 0) : [];
      this.splice.apply(this, [0, 0].concat(__slice.call(items)));
    }

    return EventedArray;

  })(Array);


  /**
   * Класс отвечает за получение есть ли подписки на событие и интерфейс опроса
   * @class SPoke
   */

  SPoke = (function() {
    function SPoke() {}


    /**
     * subscribed by `action` name or not?
     * @public
     * @method s
     * @param String action
     * @return Boolean
     */

    SPoke.prototype.s = function(action) {
      return this._subscribe.hasOwnProperty(action) && this._subscribe[action].length > 0;
    };


    /**
     * Interface for children. This method request for emet events
     * @public
     * @method poke
     * @return void
     */

    SPoke.prototype.poke = function() {};

    return SPoke;

  })();

  this.GAMEPAD_AXIS_AS_STICK = 1;

  this.GAMEPAD_AXIS_AS_BUTTON = 2;

  this.GAMEPAD_AXIS_AS_COMBINED = 3;

  Axis = (function(_super) {
    __extends(Axis, _super);

    _implements.call(Axis, SPoke);

    Axis.prototype.MODE = 1;

    Axis.prototype.pressed = false;

    Axis.prototype.value = 0;

    Axis.prototype._oldValue = 0;

    Axis.prototype._oldPressed = false;

    function Axis(gamepad, num, mode, positive, triggerValue) {
      var r, _value;
      if (triggerValue == null) {
        triggerValue = 127;
      }
      this.MODE = mode;
      r = Math.round;
      if (mode === 1) {
        Axis.__super__.constructor.call(this, 'change');
        _value = function() {
          return r(gamepad.axes[num] * 255);
        };
      } else if (mode === 2) {
        Axis.__super__.constructor.call(this, 'change', 'press', 'down', 'up');
        _value = function() {
          if (positive) {
            return r(gamepad.axes[num] * 255) > triggerValue;
          } else {
            return r(gamepad.axes[num] * 255) < -triggerValue;
          }
        };
        this._oldPressed = _value();
      } else if (mode === 3) {
        Axis.__super__.constructor.call(this, 'change', 'press', 'down', 'up');
        _value = function(press) {
          if (press) {
            if (positive) {
              return (gamepad.axes[num] * 255) > triggerValue;
            } else {
              return (gamepad.axes[num] * 255) < -triggerValue;
            }
          }
          return r(gamepad.axes[num] * 255);
        };
        this._oldPressed = _value(true);
      } else {
        throwError("Axis mode not correct.");
      }
      this._oldValue = _value();
      if (mode !== 2) {
        Object.defineProperty(this, 'value', {
          get: function() {
            return _value();
          },
          set: (function(_this) {
            return function(v) {
              _this._oldValue = v;
            };
          })(this)
        });
      }
      Object.defineProperty(this, 'pressed', {
        get: function() {
          return mode !== 1 && _value(true);
        },
        set: (function(_this) {
          return function(v) {
            if (mode !== 1) {
              _this._oldPressed = v;
            }
          };
        })(this)
      });
      this.reSubscribe = function(gamepadNew) {
        gamepad = gamepadNew;
      };
    }

    Axis.prototype.poke = function() {
      var p, v;
      if (this._subscribe._length > 0) {
        if (this.s('change')) {
          if (this._oldValue !== (v = this.value)) {
            this.emet('change', new CustomEvent('change', {
              detail: {
                oldValue: this._oldValue,
                newValue: v
              }
            }));
          }
        }
        if (this.MODE === 2 || this.MODE === 3) {
          if (this.s('press') || this.s('down') || this.s('up')) {
            if ((p = this.pressed) !== this._oldPressed) {
              if (p) {
                if (this.s("down")) {
                  this.emet('down');
                }
              } else {
                if (this.s("up")) {
                  this.emet("up");
                }
                if (this.s("press")) {
                  this.emet('press');
                }
              }
              this.pressed = p;
            }
          }
        }
        if (v != null) {
          this._oldValue = v;
        }
      }
    };

    Axis.prototype.reSubscribe = function(gamepadNew) {};

    return Axis;

  })(EventTargetEmiter);

  Button = (function(_super) {
    __extends(Button, _super);

    Button.prototype.MODE = 2;

    _implements.call(Button, SPoke);

    Button.prototype.pressed = false;

    Button.prototype._oldPressed = false;

    function Button(gamepad, num, asAxis) {
      var _value, _webkit;
      if (asAxis == null) {
        asAxis = false;
      }
      if (typeof gamepad !== "object") {
        throwError("gamepad is not Gamepad");
        return;
      }
      if (!isFinite(num)) {
        throwError("num of button not number");
        return;
      }
      num = num | 0;
      if (num < 0) {
        throwError("Index button less than 0");
        return;
      }
      if (gamepad.buttons[num] == null) {
        throwError("Button: button " + num + " not exists");
        return;
      }
      Button.__super__.constructor.call(this, 'change', 'press', 'down', 'up');
      if (_webkit = isFinite(gamepad.buttons[0])) {
        _value = function() {
          return gamepad.buttons[num] > 0.5;
        };
      } else {
        _value = function() {
          return gamepad.buttons[num].pressed;
        };
      }
      Object.defineProperty(this, 'pressed', {
        get: function() {
          return _value();
        },
        set: (function(_this) {
          return function(v) {
            _this._oldPressed = v;
          };
        })(this)
      });
      if (asAxis) {
        this.MODE = 3;
        this._oldValue = -255;
        if (_webkit) {
          Object.defineProperty(this, 'value', {
            get: function() {
              return (2 * gamepad.buttons[num] - 1) * 255;
            },
            set: function(v) {
              this._oldValue = v;
            }
          });
        } else {
          Object.defineProperty(this, 'value', {
            get: function() {
              return (2 * gamepad.buttons[num].value - 1) * 255;
            },
            set: function(v) {
              this._oldValue = v;
            }
          });
        }
      }
      this.reSubscribe = function(gamepadNew) {
        return gamepad = gamepadNew;
      };
    }

    Button.prototype.poke = function() {
      var p, v;
      if (this._subscribe._length > 0) {
        if (this.s('change')) {
          if (this.MODE & 1) {
            if (this._oldValue !== (v = this.value)) {
              this.emet('change', new CustomEvent('change', {
                detail: {
                  oldValue: this._oldValue,
                  newValue: v
                }
              }));
            }
          } else {
            if (this._oldPressed !== (p = this.pressed)) {
              this.emet("change", new CustomEvent('change', {
                detail: {
                  oldValue: !p,
                  newValue: p
                }
              }));
            }
          }
        }
        if (this._oldPressed !== (p = this.pressed)) {
          if (p) {
            if (this.s("down")) {
              this.emet("down");
            }
          } else {
            if (this.s("up")) {
              this.emet("up");
            }
            if (this.s("press")) {
              this.emet("press");
            }
          }
          return this.pressed = p;
        }
      }
    };

    Button.prototype.reSubscribe = function(gamepadNew) {};

    return Button;

  })(EventTargetEmiter);


  /**
   * Logical block width axes, buttons and collect events
   * Лоический блок, объеденяющий оси и кнопки по некоторому принаку
   * @class Block
   * @extends EventedArray //зачем массив? Иначально нужен был массив,но потом передумал
   * @implements SPoke
   */

  Block = (function(_super) {
    __extends(Block, _super);

    _implements.call(Block, SPoke);


    /**
     * ссылка на оригиналный джойстик
     * @public
     * @type Gamepad
     */

    Block.prototype.gamepad = null;


    /**
     * Карта кнопок для блока
     * @public
     * @type Object
     */

    Block.prototype.map = null;


    /**
     * На основе карты `map` из `gamepad` создаём `Block`
     * @constructor
     * @param Object map GamepadMapBlock
     * @param Gamepad gamepad
     */

    function Block(map, gamepad) {
      EventTargetEmiter.call(this, 'change');
      this.gamepad = gamepad;
      this._mapParse(map);
    }


    /**
     * Анализирует карту и создаёт элементы блока на её основе.
     * @protected
     * @method _mapParse
     * @param Object map GamepadMapBlock
     * @return void
     */

    Block.prototype._mapParse = function(map) {
      var axis, button, name, val;
      this.map = map;
      for (name in map) {
        if (!__hasProp.call(map, name)) continue;
        val = map[name];
        if (val == null) {
          delete map[name];
          continue;
        }
        if (val.hasOwnProperty('axis') && (val.axis != null)) {
          axis = new Axis(this.gamepad, val.axis, val.mode || AS_STICK, Boolean(val.positive), val.triggerValue || 0);
          if ('onchange' in axis) {
            this[name] = axis;
          } else {
            delete map[name];
            continue;
          }
        } else if (val.hasOwnProperty('button') && (val.button != null)) {
          button = new Button(this.gamepad, val.button, val.asAxis);
          if ('onchange' in button) {
            this[name] = button;
          } else {
            delete map[name];
            continue;
          }
        } else {
          throwError("Value " + name + " of MAP incorrect!");
          return;
        }
        this[name].on('change', (function(_this) {
          return function(e) {
            _this.emet('change', e);
          };
        })(this));
      }
    };


    /**
     * Добавляет обработчики к элементам при подписке на изменения
     * @public
     * @implements EventTargetEmiter
     * @param String type
     * @return void
     */

    Block.prototype.addEventListener = function(type) {
      var name, _ref;
      if (type === 'change' && !this.s('change')) {
        _ref = this.map;
        for (name in _ref) {
          if (!__hasProp.call(_ref, name)) continue;
          this[name].on('change', (function(_this) {
            return function(e) {
              _this.emet('change', e);
            };
          })(this));
        }
      }
      return Block.__super__.addEventListener.apply(this, arguments);
    };


    /**
     * Переподписывает блок на новый экемпляр `gamepad`
     * @public
     * @method reSubscribe
     * @param Gamepad gamepad
     * @return void
     */

    Block.prototype.reSubscribe = function(gamepad) {
      var name, val, _ref;
      this.gamepad = gamepad;
      _ref = this.map;
      for (name in _ref) {
        if (!__hasProp.call(_ref, name)) continue;
        val = _ref[name];
        if (this[name] == null) {
          continue;
        }
        if (val.hasOwnProperty('axis')) {
          this[name].reSubscribe(gamepad);
        } else if (val.hasOwnProperty('button')) {
          this[name].reSubscribe(gamepad);
        } else {
          throwError("Map was be wrong changed or crashed");
        }
      }
    };


    /**
     * Дёргает дочерние объекты
     * @public
     * @implements SPoke
     * @method poke
     * @return void
     */

    Block.prototype.poke = function() {
      var name, _ref;
      _ref = this.map;
      for (name in _ref) {
        if (!__hasProp.call(_ref, name)) continue;
        this[name].poke();
      }
    };

    return Block;

  })(EventedArray);

  GamepadMap = (function() {
    GamepadMap.prototype.vendor = "";

    GamepadMap.prototype.product = "";

    GamepadMap.prototype.platform = "linux";

    GamepadMap.prototype.activeMap = null;

    GamepadMap.platformDetect = function() {
      var isLinux, isMac, isWindows, platform;
      isLinux = /linux/i;
      isMac = /mac/i;
      isWindows = /win/i;
      platform = navigator.platform;
      if (isLinux.test(platform)) {
        return "linux";
      } else if (isMac.test(platform)) {
        return "mac";
      } else if (isWindows.test(platform)) {
        return "windows";
      } else {
        throwWarn("Mobile or other not supported platform");
        return "other";
      }
    };

    function GamepadMap(vendor, product, platform, overideMap) {
      if (overideMap == null) {
        overideMap = null;
      }
      if (!(isString(vendor) && vendor.length === 4 && /[a-f0-9]/i.test(vendor))) {
        throwError("GamepadMap: vendor incorrect: " + vendor);
        return;
      }
      if (!(isString(product) && product.length === 4 && /[a-f0-9]/i.test(product))) {
        throwError("GamepadMap: product incorrect: " + product);
        return;
      }
      this.vendor = vendor.toLowerCase();
      this.product = product.toLowerCase();
      this.platform = platform || GamepadMap.platformDetect();
      this.activeMap = this.loadMap();
      if (overideMap != null) {
        merge(this.activeMap, overideMap);
      }
    }

    GamepadMap.prototype.loadMap = function() {
      var defaultMap, index, map, mapsByPlatform;
      index = this.vendor + this.product;
      if (!(isString(index) && index.length === 8 && /[a-f0-9]/.test(index))) {
        throwError("GamepadMap: in map changed vendor or product and he incorrect");
        return;
      }
      defaultMap = this.other["00000000"];
      if (index === "00000000") {
        return defaultMap;
      }
      mapsByPlatform = this[this.platform];
      if (mapsByPlatform == null) {
        throwWarn("GamepadMap: platform " + this.platform + " not supported. Use default map.");
        return defaultMap;
      }
      if (!(index in mapsByPlatform)) {
        throwWarn("GamepadMap: vendor " + this.vendor + " or product " + this.product + " not supported. Use default map.");
        return defaultMap;
      }
      map = mapsByPlatform[index];
      if (isString(map)) {
        if (map in mapsByPlatform) {
          return overlay(defaultMap, mapsByPlatform[map]);
        }
        throwWarn("GamepadMap: index " + index + " of map not avialable.");
        return defaultMap;
      }
      return overlay(defaultMap, map) || defaultMap;
    };

    GamepadMap.prototype.linux = {
      "045e028e": "XInputStyleGamepad",
      "045e028f": "XInputStyleGamepad",
      "046dc21d": "XInputStyleGamepad",
      "046dc21e": "XInputStyleGamepad",
      "046dc21f": "XInputStyleGamepad",
      "23781008": "XInputStyleGamepad",
      "2378100a": "XInputStyleGamepad",
      "046dc216": "DirectInputStyle",
      "046dc218": "DirectInputStyle",
      "046dc219": "DirectInputStyle",
      "09250005": "LakeviewResearch",
      "09258866": "LakeviewResearch",
      "054c0268": "PlaystationSixAxis",
      "054c05c4": "Dualshock4",
      "0e8f0003": "XGEAR",
      "00790006": "MapperDragonRiseGeneric",
      "18d12c40": "ADT1",
      "XInputStyleGamepad": {
        lrtb: {
          LT: {
            axis: 2,
            positive: true,
            mode: 3,
            triggerValue: 0
          },
          RT: {
            axis: 5,
            positive: true,
            mode: 3,
            triggerValue: 0
          }
        },
        menu: {
          back: {
            button: 6
          },
          start: {
            button: 7
          },
          home: {
            button: 8
          }
        },
        axes: {
          LSB: {
            button: 9
          },
          RSB: {
            button: 10
          },
          RSX: {
            axis: 3,
            mode: 1
          },
          RSY: {
            axis: 4,
            mode: 1
          }
        },
        dpad: {
          up: {
            axis: 7,
            positive: false,
            mode: 2
          },
          down: {
            axis: 7,
            positive: true,
            mode: 2
          },
          left: {
            axis: 6,
            positive: false,
            mode: 2
          },
          right: {
            axis: 6,
            positive: true,
            mode: 2
          }
        }
      },
      "DirectInputStyle": {
        face: {
          PR: {
            button: 1
          },
          SC: {
            button: 2
          },
          TR: {
            button: 0
          }
        },
        menu: {
          home: null
        },
        dpad: {
          up: {
            axis: 5,
            positive: false,
            mode: 2
          },
          down: {
            axis: 5,
            positive: true,
            mode: 2
          },
          left: {
            axis: 4,
            positive: false,
            mode: 2
          },
          right: {
            axis: 4,
            positive: true,
            mode: 2
          }
        }
      },
      "LakeviewResearch": {
        face: {
          PR: {
            button: 2
          },
          TR: {
            button: 3
          },
          QT: {
            button: 0
          }
        },
        lrtb: {
          LB: {
            button: 6
          },
          RB: {
            button: 7
          },
          LT: {
            button: 4
          },
          RT: {
            button: 5
          }
        },
        menu: {
          back: {
            button: 9
          },
          start: {
            button: 8
          }
        },
        dpad: {
          up: {
            axis: 5,
            positive: false,
            mode: 2
          },
          down: {
            axis: 5,
            positive: true,
            mode: 2
          },
          left: {
            axis: 4,
            positive: false,
            mode: 2
          },
          right: {
            axis: 4,
            positive: true,
            mode: 2
          }
        }
      },
      "PlaystationSixAxis": {
        face: {
          PR: {
            button: 14
          },
          SC: {
            button: 13
          },
          TR: {
            button: 15
          },
          QT: {
            button: 12
          }
        },
        lrtb: {
          LB: {
            button: 10
          },
          RB: {
            button: 11
          },
          LT: {
            axis: 12,
            positive: true,
            mode: 3,
            triggerValue: 0
          },
          RT: {
            axis: 13,
            positive: true,
            mode: 3,
            triggerValue: 0
          }
        },
        menu: {
          back: {
            button: 0
          },
          start: {
            button: 3
          },
          home: {
            button: 16
          }
        },
        axes: {
          LSB: {
            button: 1
          },
          RSB: {
            button: 2
          }
        },
        dpad: {
          up: {
            axis: 8,
            positive: true,
            mode: 2,
            triggerValue: 0
          },
          down: {
            axis: 10,
            positive: true,
            mode: 2,
            triggerValue: 0
          },
          left: {
            button: 7
          },
          right: {
            axis: 9,
            positive: true,
            mode: 2,
            triggerValue: 0
          }
        }
      },
      "Dualshock4": {
        face: {
          PR: {
            button: 1
          },
          SC: {
            button: 2
          },
          TR: {
            button: 0
          },
          QT: {
            button: 3
          }
        },
        lrtb: {
          LT: {
            axis: 3,
            positive: true,
            mode: 3,
            triggerValue: 0
          },
          RT: {
            axis: 4,
            positive: true,
            mode: 3,
            triggerValue: 0
          }
        },
        menu: {
          home: {
            button: 12
          },
          touch: {
            button: 13
          }
        },
        axes: {
          RSY: {
            axis: 5,
            mode: 1
          }
        },
        dpad: {
          up: {
            axis: 7,
            positive: false,
            mode: 2
          },
          down: {
            axis: 7,
            positive: true,
            mode: 2
          },
          left: {
            axis: 6,
            positive: false,
            mode: 2
          },
          right: {
            axis: 6,
            positive: true,
            mode: 2
          }
        }
      },
      "XGEAR": {
        face: {
          PR: {
            button: 2
          },
          SC: {
            button: 1
          },
          TR: {
            button: 3
          },
          QT: {
            button: 0
          }
        },
        lrtb: {
          LB: {
            button: 6
          },
          RB: {
            button: 7
          },
          LT: {
            button: 4,
            asAxis: true
          },
          RT: {
            button: 5,
            asAxis: true
          }
        },
        dpad: {
          up: {
            axis: 5,
            positive: false,
            mode: 2
          },
          down: {
            axis: 5,
            positive: true,
            mode: 2
          },
          left: {
            axis: 4,
            positive: false,
            mode: 2
          },
          right: {
            axis: 4,
            positive: true,
            mode: 2
          }
        },
        axes: {
          RSX: {
            axis: 3,
            mode: 1
          },
          RSY: {
            axis: 2,
            mode: 1
          }
        }
      },
      "DragonRiseGeneric": {
        dpad: {
          up: {
            axis: 6,
            positive: false,
            mode: 2
          },
          down: {
            axis: 6,
            positive: true,
            mode: 2
          },
          left: {
            axis: 5,
            positive: false,
            mode: 2
          },
          right: {
            axis: 5,
            positive: true,
            mode: 2
          }
        },
        axes: {
          RSX: {
            axis: 3,
            mode: 1
          },
          RSY: {
            axis: 4,
            mode: 1
          }
        }
      },
      "ADT1": {
        lrtb: {
          LT: {
            axis: 5,
            positive: true,
            mode: 3,
            triggerValue: 0
          },
          RT: {
            axis: 4,
            positive: true,
            mode: 3,
            triggerValue: 0
          }
        },
        menu: {
          back: null,
          start: null,
          home: {
            button: 6
          }
        },
        axes: {
          LSB: {
            button: 7
          },
          RSB: {
            button: 8
          }
        },
        dpad: {
          up: {
            axis: 7,
            positive: false,
            mode: 2
          },
          down: {
            axis: 7,
            positive: true,
            mode: 2
          },
          left: {
            axis: 6,
            positive: false,
            mode: 2
          },
          right: {
            axis: 6,
            positive: true,
            mode: 2
          }
        }
      }
    };

    GamepadMap.prototype.windows = {
      "045e028e": "XInputStyleGamepad",
      "045e028f": "XInputStyleGamepad",
      "046dc21d": "XInputStyleGamepad",
      "046dc21e": "XInputStyleGamepad",
      "046dc21f": "XInputStyleGamepad",
      "23781008": "OnLiveWireless",
      "2378100a": "OnLiveWireless",
      "046dc216": "DirectInputStyle",
      "046dc218": "DirectInputStyle",
      "046dc219": "DirectInputStyle",
      "054c05c4": "Dualshock4",
      "18d12c40": "ADT1",
      "XInputStyleGamepad": {
        lrtb: {
          LT: {
            axis: 4,
            positive: true,
            mode: 3,
            triggerValue: 127
          },
          RT: {
            axis: 4,
            positive: false,
            mode: 3,
            triggerValue: 127
          }
        },
        menu: {
          back: {
            button: 6
          },
          start: {
            button: 7
          },
          home: null
        },
        axes: {
          LSB: {
            button: 8
          },
          RSB: {
            button: 9
          },
          LSX: {
            axis: 1,
            mode: 1
          },
          LSY: {
            axis: 0,
            mode: 1
          },
          RSX: {
            axis: 3,
            mode: 1
          },
          RSY: {
            axis: 2,
            mode: 1
          }
        },
        dpad: {
          up: {
            axis: 6,
            positive: false,
            mode: 2
          },
          down: {
            axis: 6,
            positive: true,
            mode: 2
          },
          left: {
            axis: 5,
            positive: false,
            mode: 2
          },
          right: {
            axis: 5,
            positive: true,
            mode: 2
          }
        }
      },
      "DirectInputStyle": {
        face: {
          PR: {
            button: 1
          },
          SC: {
            button: 2
          },
          TR: {
            button: 0
          }
        },
        menu: {
          home: null
        },
        dpad: {
          up: {
            axis: 5,
            positive: false,
            mode: 2
          },
          down: {
            axis: 5,
            positive: true,
            mode: 2
          },
          left: {
            axis: 4,
            positive: false,
            mode: 2
          },
          right: {
            axis: 4,
            positive: true,
            mode: 2
          }
        },
        axes: {
          LSX: {
            axis: 3,
            mode: 1
          },
          LSY: {
            axis: 2,
            mode: 1
          },
          RSX: {
            axis: 1,
            mode: 1
          },
          RSY: {
            axis: 0,
            mode: 1
          }
        }
      },
      "Dualshock4": {
        face: {
          PR: {
            button: 1
          },
          SC: {
            button: 2
          },
          TR: {
            button: 0
          },
          QT: {
            button: 3
          }
        },
        lrtb: {
          LT: {
            axis: 3,
            positive: true,
            mode: 3,
            triggerValue: 0
          },
          RT: {
            axis: 4,
            positive: true,
            mode: 3,
            triggerValue: 0
          }
        },
        menu: {
          home: {
            button: 12
          },
          touch: {
            button: 13
          }
        },
        axes: {
          RSY: {
            axis: 5,
            mode: 1
          }
        },
        dpad: {
          up: {
            axis: 7,
            positive: false,
            mode: 2
          },
          down: {
            axis: 7,
            positive: true,
            mode: 2
          },
          left: {
            axis: 6,
            positive: false,
            mode: 2
          },
          right: {
            axis: 6,
            positive: true,
            mode: 2
          }
        }
      },
      "OnLiveWireless": {
        face: {
          TR: {
            button: 3
          },
          QT: {
            button: 4
          }
        },
        lrtb: {
          LB: {
            button: 6
          },
          RB: {
            button: 7
          },
          LT: {
            axis: 2,
            positive: true,
            mode: 3,
            triggerValue: 0
          },
          RT: {
            axis: 5,
            positive: true,
            mode: 3,
            triggerValue: 0
          }
        },
        menu: {
          back: {
            button: 10
          },
          start: {
            button: 11
          },
          home: {
            button: 12
          }
        },
        dpad: {
          up: {
            axis: 7,
            positive: false,
            mode: 2
          },
          down: {
            axis: 7,
            positive: true,
            mode: 2
          },
          left: {
            axis: 6,
            positive: false,
            mode: 2
          },
          right: {
            axis: 6,
            positive: true,
            mode: 2
          }
        },
        axes: {
          LSB: {
            button: 13
          },
          RSB: {
            button: 14
          },
          RSX: {
            axis: 3,
            mode: 1
          },
          RSY: {
            axis: 4,
            mode: 1
          }
        }
      },
      "ADT1": {
        face: {
          TR: {
            button: 3
          },
          QT: {
            button: 4
          }
        },
        lrtb: {
          lrtb: {
            LB: {
              button: 6
            },
            RB: {
              button: 7
            }
          },
          LT: {
            axis: 4,
            positive: true,
            mode: 3,
            triggerValue: 0
          },
          RT: {
            axis: 3,
            positive: true,
            mode: 3,
            triggerValue: 0
          }
        },
        menu: {
          back: null,
          start: null,
          home: {
            button: 6
          }
        },
        axes: {
          LSB: {
            button: 13
          },
          RSB: {
            button: 14
          },
          RSY: {
            axis: 5,
            mode: 1
          }
        },
        dpad: {
          up: {
            axis: 7,
            positive: false,
            mode: 2
          },
          down: {
            axis: 7,
            positive: true,
            mode: 2
          },
          left: {
            axis: 6,
            positive: false,
            mode: 2
          },
          right: {
            axis: 6,
            positive: true,
            mode: 2
          }
        }
      }
    };

    GamepadMap.prototype.mac = {
      "045e028e": "XInputStyleGamepad",
      "045e028f": "XInputStyleGamepad",
      "046dc21d": "XInputStyleGamepad",
      "046dc21e": "XInputStyleGamepad",
      "046dc21f": "XInputStyleGamepad",
      "23781008": "OnLiveWireless",
      "2378100a": "OnLiveWireless",
      "09250005": "LakeviewResearch",
      "09258866": "LakeviewResearch",
      "054c0268": "PlaystationSixAxis",
      "054c05c4": "Dualshock4",
      "0e8f0003": "XGEAR",
      "00790006": "MapperDragonRiseGeneric",
      "18d12c40": "ADT1",
      "XInputStyleGamepad": {
        lrtb: {
          LT: {
            axis: 2,
            positive: true,
            mode: 3,
            triggerValue: 0
          },
          RT: {
            axis: 5,
            positive: true,
            mode: 3,
            triggerValue: 0
          }
        },
        menu: {
          back: {
            button: 9
          },
          start: {
            button: 8
          },
          home: {
            button: 10
          }
        },
        axes: {
          LSB: {
            button: 6
          },
          RSB: {
            button: 7
          },
          RSX: {
            axis: 3,
            mode: 1
          },
          RSY: {
            axis: 4,
            mode: 1
          }
        },
        dpad: {
          up: {
            button: 11
          },
          down: {
            button: 12
          },
          left: {
            button: 13
          },
          right: {
            button: 14
          }
        }
      },
      "OnLiveWireless": {
        face: {
          TR: {
            button: 3
          },
          QT: {
            button: 4
          }
        },
        lrtb: {
          LB: {
            button: 6
          },
          RB: {
            button: 7
          },
          LT: {
            axis: 2,
            positive: true,
            mode: 3,
            triggerValue: 0
          },
          RT: {
            axis: 5,
            positive: true,
            mode: 3,
            triggerValue: 0
          }
        },
        menu: {
          back: {
            button: 10
          },
          start: {
            button: 11
          },
          home: {
            button: 12
          }
        },
        dpad: {
          up: {
            axis: 7,
            positive: false,
            mode: 2
          },
          down: {
            axis: 7,
            positive: true,
            mode: 2
          },
          left: {
            axis: 6,
            positive: false,
            mode: 2
          },
          right: {
            axis: 6,
            positive: true,
            mode: 2
          }
        },
        axes: {
          LSB: {
            button: 13
          },
          RSB: {
            button: 14
          },
          RSX: {
            axis: 3,
            mode: 1
          },
          RSY: {
            axis: 4,
            mode: 1
          }
        }
      },
      "LakeviewResearch": {
        face: {
          PR: {
            button: 2
          },
          TR: {
            button: 3
          },
          QT: {
            button: 0
          }
        },
        lrtb: {
          LB: {
            button: 6
          },
          RB: {
            button: 7
          },
          LT: {
            button: 4
          },
          RT: {
            button: 5
          }
        },
        menu: {
          back: {
            button: 9
          },
          start: {
            button: 8
          },
          home: null
        },
        axes: {
          RSY: {
            axis: 5,
            mode: 1
          }
        },
        dpad: {
          up: {
            axis: 4,
            positive: false,
            mode: 2
          },
          down: {
            axis: 4,
            positive: true,
            mode: 2
          },
          left: {
            axis: 3,
            positive: false,
            mode: 2
          },
          right: {
            axis: 3,
            positive: true,
            mode: 2
          }
        }
      },
      "PlaystationSixAxis": {
        face: {
          PR: {
            button: 14
          },
          SC: {
            button: 13
          },
          TR: {
            button: 15
          },
          QT: {
            button: 12
          }
        },
        lrtb: {
          LB: {
            button: 10
          },
          RB: {
            button: 11
          },
          LT: {
            axis: 14,
            positive: true,
            mode: 3,
            triggerValue: 0
          },
          RT: {
            axis: 15,
            positive: true,
            mode: 3,
            triggerValue: 0
          }
        },
        menu: {
          back: {
            button: 0
          },
          start: {
            button: 3
          },
          home: {
            button: 16
          }
        },
        axes: {
          LSB: {
            button: 1
          },
          RSB: {
            button: 2
          },
          RSY: {
            axis: 5
          }
        },
        dpad: {
          up: {
            button: 4
          },
          down: {
            button: 6
          },
          left: {
            button: 7
          },
          right: {
            button: 5
          }
        }
      },
      "Dualshock4": {
        face: {
          PR: {
            button: 1
          },
          SC: {
            button: 2
          },
          TR: {
            button: 0
          },
          QT: {
            button: 3
          }
        },
        lrtb: {
          LT: {
            axis: 3,
            positive: true,
            mode: 3,
            triggerValue: 0
          },
          RT: {
            axis: 4,
            positive: true,
            mode: 3,
            triggerValue: 0
          }
        },
        menu: {
          home: {
            button: 12
          },
          touch: {
            button: 13
          }
        },
        axes: {
          RSY: {
            axis: 5,
            mode: 1
          }
        },
        dpad: {
          up: {
            axis: 7,
            positive: false,
            mode: 2
          },
          down: {
            axis: 7,
            positive: true,
            mode: 2
          },
          left: {
            axis: 6,
            positive: false,
            mode: 2
          },
          right: {
            axis: 6,
            positive: true,
            mode: 2
          }
        }
      },
      "XGEAR": {
        face: {
          PR: {
            button: 2
          },
          SC: {
            button: 1
          },
          TR: {
            button: 3
          },
          QT: {
            button: 0
          }
        },
        lrtb: {
          LB: {
            button: 6
          },
          RB: {
            button: 7
          },
          LT: {
            button: 4,
            asAxis: true
          },
          RT: {
            button: 5,
            asAxis: true
          }
        },
        dpad: {
          up: {
            axis: 4,
            positive: false,
            mode: 2
          },
          down: {
            axis: 4,
            positive: true,
            mode: 2
          },
          left: {
            axis: 3,
            positive: false,
            mode: 2
          },
          right: {
            axis: 3,
            positive: true,
            mode: 2
          }
        },
        home: null,
        axes: {
          RSX: {
            axis: 5,
            mode: 1
          },
          RSY: {
            axis: 2,
            mode: 1
          }
        }
      },
      "DragonRiseGeneric": {
        dpad: {
          up: {
            axis: 4,
            positive: false,
            mode: 2
          },
          down: {
            axis: 4,
            positive: true,
            mode: 2
          },
          left: {
            axis: 3,
            positive: false,
            mode: 2
          },
          right: {
            axis: 3,
            positive: true,
            mode: 2
          }
        },
        menu: {
          home: null
        },
        axes: {
          RSY: {
            axis: 5,
            mode: 1
          }
        }
      },
      "ADT1": {
        face: {
          TR: 3,
          QT: 4
        },
        lrtb: {
          LT: {
            axis: 3,
            positive: true,
            mode: 3,
            triggerValue: 0
          },
          RT: {
            axis: 4,
            positive: true,
            mode: 3,
            triggerValue: 0
          }
        },
        menu: {
          back: null,
          start: null,
          home: {
            button: 12
          }
        },
        axes: {
          LSB: {
            button: 13
          },
          RSB: {
            button: 14
          },
          RSY: {
            axis: 5
          }
        },
        dpad: {
          up: {
            axis: 7,
            positive: false,
            mode: 2
          },
          down: {
            axis: 7,
            positive: true,
            mode: 2
          },
          left: {
            axis: 6,
            positive: false,
            mode: 2
          },
          right: {
            axis: 6,
            positive: true,
            mode: 2
          }
        }
      }
    };

    GamepadMap.prototype.other = {
      "example": {
        blockName: {
          buttonName: {
            button: 0,
            asAxis: false,
            axis: null
          },
          axisName: {
            axis: 0,
            mode: GAMEPAD_AXIS_AS_COMBINED,
            positive: true,
            triggerValue: 127
          }
        }
      },
      "00000000": {
        face: {
          PR: {
            button: 0
          },
          SC: {
            button: 1
          },
          TR: {
            button: 2
          },
          QT: {
            button: 3
          }
        },
        lrtb: {
          LB: {
            button: 4
          },
          RB: {
            button: 5
          },
          LT: {
            button: 6,
            asAxis: true
          },
          RT: {
            button: 7,
            asAxis: true
          }
        },
        menu: {
          back: {
            button: 8
          },
          start: {
            button: 9
          },
          home: {
            button: 16
          }
        },
        axes: {
          LSB: {
            button: 10
          },
          LSX: {
            axis: 0,
            mode: 1
          },
          LSY: {
            axis: 1,
            mode: 1
          },
          RSB: {
            button: 11
          },
          RSX: {
            axis: 2,
            mode: 1
          },
          RSY: {
            axis: 3,
            mode: 1
          }
        },
        dpad: {
          up: {
            button: 12
          },
          down: {
            button: 13
          },
          left: {
            button: 14
          },
          right: {
            button: 15
          }
        }
      }
    };

    return GamepadMap;

  })();

  this.GAMEPAD_NAME_FULL = 0x2;

  this.GAMEPAD_NAME_SHORT = 0x1;


  /**
   * Interface for gamepad. Button have events press, up and down, sticks have method change.
   * Buttons and sticks apportioned by logical blocks:
   * `dpad` -- left + buttons
   * `lrtb` -- left/right tob/button buttons (triggers and shoulders)
   * `menu` -- central buttons back/select  start/forward and meta/home
   * `axes` -- stcks and stick buttons
   * `face` -- right 4 action-buttons
   *
   * config:
   * Mode of `naming` declare name of blocks and buttons. Recommend use short naming.
   * `maps` is array of `GamepadMap` -- modifed, corrected or new mapping for gamepads. 
   * Map have vendor, product and platform id, and apply only on this. 
   * If custom map have custom block name, you need set `allowCustomBlockNaming` else throw
   * error.
   * To skip config check set `trusted` is true.
   *
   * Основной интерфейс для джойстика. У кнопок есть события нажатия, а у стиков -- изменения
   * Кнопки и блоки разнесены по логическим блокам:
   * `dpad` -- крестовина
   * `lrtb` -- верхние тригерр и бампер (R1 L1 R2 L2 в нотации PS)
   * `menu` -- кнопки меню в центре
   * `axes` -- стики и кнопки стиков
   * `face` -- кнопки справа
   *
   * конфигурация (по умолчанию транслируется из Gamepads)
   * Параметр `naming`определяет режим названия блоков и кнопок. Если маска содержит 
   * `GAMEPAD_NAME_FULL`, то названия некоторых блоков и кнопок альтернативные указанным.
   * `maps` если не `null` является массивом объектов `GamepadMap, в который указаны vendor,
   * prodict и platform, которые определяют применимость карты только при полном совпадении. 
   * Если блок имеет имя отлично от вышеописанных, то следует указать `allowCustomBlockName`
   * в противном случае будет брошена ошибка.
   * Чтобы не проверять правильность конфигурации, следует установить `trusted`
   *
   * @class Gamepad2
   * @extends EventTargetEmiter
   * @implements SPoke
   */

  Gamepad2 = (function(_super) {
    var associate, defaultConfig, parseConfig, parseId, _synonyms;

    __extends(Gamepad2, _super);

    _implements.call(Gamepad2, SPoke);


    /**
     * Статус джойстика
     * @public
     * @type Boolean
     */

    Gamepad2.prototype.connected = false;


    /**
     * Ссылка на базовый джойстик
     * @public
     * @type Gamepad
     */

    Gamepad2.prototype.gamepad = null;


    /**
     * Текущая карта кнопоки осей
     * @public
     * @type GamepadMap
     */

    Gamepad2.prototype.map = null;


    /**
     * Блок стиков
     * @public
     * @type Block
     */

    Gamepad2.prototype.axes = null;


    /**
     * Блок крестовины
     * @public
     * @type Block
     */

    Gamepad2.prototype.dpad = null;


    /**
     * Блок кнопок справа
     * @public
     * @type Block
     */

    Gamepad2.prototype.face = null;


    /**
     * Блок верхних кнопок (тригер, бампер)
     * @public
     * @type Block
     */

    Gamepad2.prototype.lrtb = null;


    /**
     * Блок кнопок взаимодействия с меню
     * @public
     * @type Block
     */

    Gamepad2.prototype.menu = null;


    /**
     * Конфигурация текущая
     * @public
     * @type Object
     */

    Gamepad2.prototype.config = null;


    /**
     * Конфигурация по-умолчанию
     * @private
     * @type Object
     */

    defaultConfig = {
      naming: GAMEPAD_NAME_FULL | GAMEPAD_NAME_SHORT,
      maps: null,
      allowCustomBlockName: false,
      trusted: false
    };


    /**
     * Создаёт на основе `gamepad` с учётом `config` экземпляр класса.
     * @constructor
     * @param Gamepad gamepad
     * @param Object config = {}
     */

    function Gamepad2(gamepad, config) {
      var map, mapCandidat, vp, _i, _len, _ref;
      if (config == null) {
        config = {};
      }
      config = overlay(defaultConfig, config);
      this.config = parseConfig(config);
      Gamepad2.__super__.constructor.call(this, 'change', 'on', 'off');
      this.gamepad = gamepad;
      mapCandidat = null;
      if (gamepad.axes.length === 4) {
        this.map = new GamepadMap("0000", "0000");
      } else {
        if (config.maps != null) {
          vp = parseId(gamepad.id);
          vp[0] = GamepadMap.platformDetect();
          _ref = config.maps;
          for (_i = 0, _len = _ref.length; _i < _len; _i++) {
            map = _ref[_i];
            if (map.platform === vp[0] && map.vendor.toLowerCase() === vp[1] && map.product.toLowerCase() === vp[2]) {
              mapCandidat = map;
              break;
            }
          }
          if (mapCandidat == null) {
            throwInfo("Gamepad2: manual map not find allowed. Use default mapper");
          }
        }
        if (mapCandidat != null) {
          this.map = mapCandidat;
        } else {
          this.getMap(gamepad.id);
        }
      }
    }


    /**
     * Устанавливает текущую карту кнопок по `id` из `gamepad.id`
     * @public
     * @method getMap
     * @param String id
     * @return GamepadMap
     */

    Gamepad2.prototype.getMap = function(id) {
      var parsed;
      parsed = parseId(id);
      return this.map = new GamepadMap(parsed[1], parsed[2]);
    };


    /**
     * Переопределяет текущую карту кнопок на новую из `map` принудительно.
     * @public
     * @method reMap
     * @param GamepadMap map
     * @return void
     */

    Gamepad2.prototype.reMap = function(map) {
      var block, blockName, _ref;
      if (!(map instanceof GamepadMap)) {
        throwError("Gamepad2: reMap: map must be instance of GamepadMap");
        return;
      }
      this.map = map;
      _ref = map.activeMap;
      for (blockName in _ref) {
        if (!__hasProp.call(_ref, blockName)) continue;
        block = _ref[blockName];
        if ((blockName in this) || this.config.allowCustomBlockName === true) {
          if (this[blockName] == null) {
            associate(this, this.config.naming, blockName, block);
          } else {
            this[blockName].reSubscribe(this.gamepad);
          }
        } else {
          delete map.activeMap[blockName];
        }
      }
    };


    /**
     * Метод, вызываемый при подключении джойстика
     * @public
     * @method connect
     * @return void
     */

    Gamepad2.prototype.connect = function() {
      this.reMap(this.map);
      this.connected = true;
      this.emet("on");
    };


    /**
     * Метод, вызываемый при отключении джойстика
     * @public
     * @method disconnect
     * @return void
     */

    Gamepad2.prototype.disconnect = function() {
      this.connected = false;
      this.emet("off");
    };


    /**
     * @public
     * @method poke
     * @implements SPoke
     * @return void
     */

    Gamepad2.prototype.poke = function() {
      var block, _ref;
      if (!this.connected) {
        return;
      }
      _ref = this.map.activeMap;
      for (block in _ref) {
        if (!__hasProp.call(_ref, block)) continue;
        this[block].poke();
      }
    };


    /**
     * Анализирует конфигураци, в случае ошибочности, берёт значения по-умолчанию
     * @private
     * @method parseConfig
     * @param Object config
     * @return void
     */

    parseConfig = function(config) {
      var booleanTest, index, map, maskTest, warn, wrongMap, _i, _j, _len, _ref;
      if (!config) {
        throwError("Gamepad2: config: config is empty. Merging fail.");
        return;
      }
      if (typeof config !== "object") {
        throwError("Gamepad2: config: config not object.");
        return;
      }
      if (config.trusted === true) {
        return config;
      }
      warn = function(warntext) {
        return throwWarn("Gamepads: config: " + warntext + ". Set default");
      };
      booleanTest = function(name, warntext) {
        if (config[name] !== !!config[name]) {
          warn(warntext);
          config[name] = defaultConfig[name];
          false;
        }
        return true;
      };
      maskTest = function(name, maxMask, notMask, notAllowedMask) {
        var v;
        v = config[name];
        if (((+v) | 0) !== v) {
          warn(notMask);
        } else if (v > maxMask) {
          warn(notAllowedMask);
        } else {
          return true;
        }
        config[name] = defaultConfig[name];
        return false;
      };
      maskTest('naming', GAMEPAD_NAME_FULL | GAMEPAD_NAME_SHORT, "naming must be bitmask", "not allowed values for naming bitmask");
      booleanTest("allowCustomBlockName", "allowCustomBlockName must be boolean");
      if (config.map != null) {
        if (config.map instanceof GamepadMap) {
          config.map = [config.map];
        }
        if (!(config.map instanceof Array)) {
          warn("map must be array of gamepadMap instance or gamepadMap instance");
          config.map = null;
        }
        wrongMap = [];
        _ref = config.map;
        for (index = _i = 0, _len = _ref.length; _i < _len; index = ++_i) {
          map = _ref[index];
          if (!(map instanceof GamepadMap)) {
            warn("map " + index + " not instance of GamepadMap. Use constructor for create map");
            wrongMap.push(index);
          }
        }
        for (_j = wrongMap.length - 1; _j >= 0; _j += -1) {
          index = wrongMap[_j];
          config.map.splice(index, 1);
        }
        if (config.map.length === 0) {
          config.map = null;
        }
      }
      return config;
    };


    /**
     * Преобразует `id` в значения vendor, product
     * @private
     * @method parseId
     * @param String id
     * return Array [*, String(4) vendorId, String(4) productId]
     */

    parseId = function(id) {
      var moz, other, vp, webkit;
      moz = /([0-9a-f]{1,4})\-([0-9a-f]{1,4})\-[\s\w]+/;
      webkit = /Vendor: ([0-9a-f]{1,4}) Product: ([0-9a-f]{1,4})/;
      other = /\b([0-9a-f]{4})\b.+\b([0-9a-f]{4})\b/;
      if (moz.test(id)) {
        vp = id.match(moz);
      } else if (webkit.test(id)) {
        vp = id.match(webkit);
      } else if (other.test(id)) {
        vp = id.match(other);
      } else {
        vp = [null, "0000", "0000"];
      }
      vp[1] = zeroFill(vp[1], 4);
      vp[2] = zeroFill(vp[2], 4);
      return vp;
    };


    /**
     * Синонимы коротких и длинных названий кнопок и блоков.
     * @private
     * @type Array
     */

    _synonyms = [["PR", "primary"], ["SC", "secondary"], ["TR", "tertiary"], ["QT", "quaternary"], ["lrtb", "shouldersTriggers"], ["dpad", "dPad"], ["LB", "leftShoulder"], ["RB", "rightShoulder"], ["LT", "leftTrigger"], ["RT", "rightTrigger"], ["LSB", "leftStickButton"], ["RSB", "rightStickButton"]];


    /**
     * Функция твечающая за конечное именования блока и кнопок в зависимости от конфигурации
     * @private
     * @method associate
     * @param Gamepad2 pad usualy for this
     * @param Number|MASK mode
     * @param String blockName
     * @paeam Object mapBlock detail of GamepadMap
     * @return void
     */

    associate = function(pad, mode, blockName, mapBlock) {
      var blockNames, find, name, names, val;
      find = function(name) {
        var syn, _i, _len;
        for (_i = 0, _len = _synonyms.length; _i < _len; _i++) {
          syn = _synonyms[_i];
          if (syn[0] === name || syn[1] === name) {
            return syn;
          }
        }
        return [name, name];
      };
      blockNames = find(blockName);
      for (name in mapBlock) {
        if (!__hasProp.call(mapBlock, name)) continue;
        val = mapBlock[name];
        names = find(name);
        delete mapBlock[name];
        if (mode & 0x1) {
          mapBlock[names[0]] = val;
        }
        if (mode & 0x2) {
          mapBlock[names[1]] = val;
        }
      }
      if (mode & 0x1) {
        pad[blockNames[0]] = new Block(mapBlock, pad.gamepad);
        if (mode & 0x2) {
          pad[blockNames[1]] = pad[blockNames[0]];
        }
      } else if (mode & 0x2) {
        pad[blockNames[1]] = new Block(mapBlock, pad.gamepad);
      }
    };

    return Gamepad2;

  })(EventTargetEmiter);

  top = this;


  /**
   * Массив джойстиков с возможностью отслеживания их подключения, отключения.
   * @class Gamepads
   * @extends EventedArray
   */

  Gamepads = (function(_super) {

    /**
     * Поддерживается ли интерфейс в принципе.
     * @private
     * @type Boolean
     */
    var defaultConfig, parseConfig, _reQueue, _support, _webkitPoolSheduller, _webkitStyle;

    __extends(Gamepads, _super);

    _support = false;


    /**
     * Реализация только в стиле webkit? В противном случае полная реализация.
     * @private
     * @type Boolean
     */

    _webkitStyle = false;


    /**
     * Ссылк на таймер.
     * @private
     * @type shedullerId|Number
     */

    _webkitPoolSheduller = null;


    /**
     * Массив заданий для webkit
     * @private
     * @type Array
     */

    _reQueue = [];


    /**
     * Config by default.
     * @private
     * @type Object
     */

    defaultConfig = {
      silent: true,
      autoDetect: true,
      frequencyUpdate: 60,
      webkitFrequencyUpdate: 10,
      webkitInactiveDisconnect: 15 * 60000,
      naming: GAMEPAD_NAME_FULL | GAMEPAD_NAME_SHORT,
      maps: null,
      allowCustomBlockName: false
    };


    /**
     * Анализирает и проверяет конфигурацию.
     * Если параметр ошибочен, то пишется предупреждение и выставляется значение по умолчанию
     * @private
     * @method parseConfig
     * @param Object config
     * @return Object
     */

    parseConfig = function(config) {
      var booleanTest, index, map, maskTest, positiveNumberTest, warn, wrongMap, _i, _j, _len, _ref;
      if (!config) {
        throwError("Gamepads: config: config is empty. Merging fail.");
        return;
      }
      if (typeof config !== "object") {
        throwError("Gamepads: config: config not object.");
        return;
      }
      warn = function(warntext) {
        return throwWarn("Gamepads: config: " + warntext + ". Set default");
      };
      booleanTest = function(name, warntext) {
        if (config[name] !== !!config[name]) {
          warn(warntext);
          config[name] = defaultConfig[name];
          false;
        }
        return true;
      };
      positiveNumberTest = function(name, noNumber, signedNumber) {
        if (!isFinite(config[name])) {
          warn(noNumber);
        } else if ((config.frequencyUpdate | 0) <= 0) {
          warn(signedNumber);
        } else {
          config[name] = config[name] | 0;
          return true;
        }
        config[name] = defaultConfig[name];
        return false;
      };
      maskTest = function(name, maxMask, notMask, notAllowedMask) {
        var v;
        v = config[name];
        if (((+v) | 0) !== v) {
          warn(notMask);
        } else if (v > maxMask) {
          warn(notAllowedMask);
        } else {
          return true;
        }
        config[name] = defaultConfig[name];
        return false;
      };
      booleanTest('silent', "fail silent format");
      silent = config.silent;
      positiveNumberTest('frequencyUpdate', "frequency update is not number", "frequency must be great then 0");
      positiveNumberTest('webkitFrequencyUpdate', "webkit frequency is not number", "webkit frequency must be great then 0");
      positiveNumberTest('webkitInactiveDisconnect', "time must be number", "time must be great then 0");
      maskTest('naming', GAMEPAD_NAME_FULL | GAMEPAD_NAME_SHORT, "naming must be bitmask", "not allowed values for naming bitmask");
      booleanTest("allowCustomBlockName", "allowCustomBlockName must be boolean");
      if (config.maps != null) {
        if (config.maps instanceof GamepadMap) {
          config.maps = [config.maps];
        }
        if (!(config.maps instanceof Array)) {
          warn("map must be array of gamepadMap instance or gamepadMap instance");
          config.maps = null;
        }
        wrongMap = [];
        _ref = config.maps;
        for (index = _i = 0, _len = _ref.length; _i < _len; index = ++_i) {
          map = _ref[index];
          if (!(map instanceof GamepadMap)) {
            warn("map " + index + " not instance of GamepadMap. Use constructor for create map");
            wrongMap.push(index);
          }
        }
        for (_j = wrongMap.length - 1; _j >= 0; _j += -1) {
          index = wrongMap[_j];
          config.maps.splice(index, 1);
        }
        if (config.maps.length === 0) {
          config.maps = null;
        }
      }
      return config;
    };


    /**
     * Инициаизвция по конфигурации. Конфигурация и значения описаны выше в `defaultConfig`
     * @constructor
     * @param Object config
     */

    function Gamepads(config) {
      var _getPad, _registered, _webkitMaxInactive;
      if (config == null) {
        config = {};
      }
      if (typeof navigator === "undefined" || navigator === null) {
        throwError("Gamepads: navigator not exists! Browser strange.");
        return;
      }
      if ((navigator.getGamepads == null) && (navigator.webkitGetGamepads == null)) {
        throwError("Gamepads: Gamepad API not yet.");
        return;
      }
      config = overlay(defaultConfig, config);
      this.config = parseConfig(config);
      EventTargetEmiter.call(this, 'on', 'off', 'add');
      if (navigator.getGamepads != null) {
        top.addEventListener('gamepadconnected', (function(_this) {
          return function(e) {
            var r;
            r = _this._addGamepad(e.gamepad);
            if (r === -1) {
              r = _this.registred[e.gamepad.id];
              if (r == null) {
                throwError("Gamepads: gamepad not added!");
                return;
              }
              _this._createEvent('on', _this[r]);
            }
          };
        })(this));
        top.addEventListener('gamepaddisconnected', (function(_this) {
          return function(e) {
            return _this._gamepadDisconnect(e.gamepad);
          };
        })(this));
      } else {
        _webkitStyle = true;
        _registered = [];
        _getPad = (function(_this) {
          return function(gamepad) {
            var pad, _i, _len, _ref;
            _ref = _this.registred[gamepad.id];
            for (_i = 0, _len = _ref.length; _i < _len; _i++) {
              pad = _ref[_i];
              if (gamepad === pad.gamepad) {
                return pad;
              }
            }
            return null;
          };
        })(this);

        /*_webkitStyle.detail =
          instance: @
          registered: _registered
         */
        _webkitMaxInactive = config.webkitInactiveDisconnect;
        _reQueue.push((function(_this) {
          return function() {
            var gamepad, r2, _i, _len, _ref;
            _ref = navigator.webkitGetGamepads();
            for (_i = 0, _len = _ref.length; _i < _len; _i++) {
              gamepad = _ref[_i];
              if (!gamepad) {
                continue;
              }
              if (__indexOf.call(_registered, gamepad) < 0) {
                _registered.push(gamepad);
                r2 = _this._addGamepad(gamepad);
                if (!gamepad.hasOwnProperty('connected')) {
                  gamepad.connected = false;
                  gamepad.timechange = Date.now() - _webkitMaxInactive;
                } else {
                  if (gamepad.connected === true) {
                    _this[r2].connect();
                    _this._createEvent('on', _this[r2]);
                  }
                }
              }
            }
          };
        })(this));
        _reQueue.push((function(_this) {
          return function() {
            var button, gamepad, pad3, pressedButton, _i, _j, _len, _len1, _ref;
            for (_i = 0, _len = _registered.length; _i < _len; _i++) {
              gamepad = _registered[_i];
              if (gamepad.connected) {
                if (Date.now() - gamepad.timechange > _webkitMaxInactive) {
                  gamepad.connected = false;
                  _this._gamepadDisconnect(gamepad);
                }
              } else if (Date.now() - gamepad.timechange < _webkitMaxInactive) {
                gamepad.connected = true;
                pad3 = _getPad(gamepad);
                if (!pad3) {
                  throwError("Gamepads: gamepad registered not created or replaced");
                  return;
                }
                pad3.connect();
                _this._createEvent('on', pad3);
              } else {
                pressedButton = false;
                _ref = gamepad.buttons;
                for (_j = 0, _len1 = _ref.length; _j < _len1; _j++) {
                  button = _ref[_j];
                  if (button) {
                    pressedButton = true;
                    break;
                  }
                }
                if (pressedButton) {
                  gamepad.timechange = Date.now();
                }
              }
            }
          };
        })(this));
      }
      navigator.getGamepads = navigator.getGamepads || navigator.webkitGetGamepads;
      this._startShedule(config.frequencyUpdate, config.webkitFrequencyUpdate);
      this.registred = {};
      _support = true;
      if (config.autoDetect) {
        this.detect();
      }
    }


    /**
     * Зарегестрированые джойстики по их ID в виде массива.
     * @example registered['026d12ad'] = [pad1, pad2, ...]
     * @public
     * @type Object
     */

    Gamepads.prototype.registred = null;


    /**
     * Current config. Must be read only, if change effect not garanted.
     * Текущая конфигурация. Изменения папрямую приведут к неизвестному результату.
     * @public
     * @type Object|Dict
     */

    Gamepads.prototype.config = null;


    /**
     * Detect exists gamepads. Can be run manual, can be run automatic if `config.autoDetect`
     * If api not supported, then return false, else return true. 
     * Add only not added gamepads. May be run safely.
     * Определяет и добавляет джойстики из системы. Можно вызвать вручную, а можно
     * автоматически, если `config.autoDetect`. Возвращает true, если интерфейс подерживается
     * и false, еси нет. Может быть безопасно вызвана несколько раз, добавлятся только те
     * джойстики, что не добавлены уже. Может быть использована дляопределения поддержки
     * интерфейса системой. 
     * @public
     * @return Boolean
     */

    Gamepads.prototype.detect = function() {
      var gamepad, _i, _len, _ref;
      if (!_support) {
        return false;
      }
      _ref = navigator.getGamepads();
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        gamepad = _ref[_i];
        this._addGamepad(gamepad);
      }
      return true;
    };


    /**
     * Упрощённое создание события.
     * @protected
     * @param String     name название события
     * @param Gamepad2  pad экземпляр, вызвавший событие
     * @return Boolean было ли перехвачено событие
     */

    Gamepads.prototype._createEvent = function(name, pad) {
      if (!isString(name)) {
        return null;
      }
      if (!pad) {
        return null;
      }
      return this.emet(name, new CustomEvent(name, {
        detail: pad
      }));
    };


    /**
     * Добавляет или переподключает джойстик.
     * @protected
     * @param Gamepad gamepad браузерный экземпляр.
     * @return Number id new Gamepad2 or -1 if not added
     */

    Gamepads.prototype._addGamepad = function(gamepad) {
      var add, pad, _i, _len, _ref;
      if (gamepad == null) {
        return -2;
      }
      add = (function(_this) {
        return function() {
          var pad2;
          pad2 = new Gamepad2(gamepad, {
            naming: _this.config.naming,
            maps: _this.config.maps,
            allowCustomBlockName: _this.config.allowCustomBlockName,
            trusted: true
          });
          if (_webkitStyle) {
            pad2.on("change", function() {
              return gamepad.timechange = Date.now();
            });
          }
          _this.push(pad2);
          _this.registred[gamepad.id] = [pad2];
          _this._createEvent('add', pad2);
          if (gamepad.connected) {
            wait(0, function() {
              return pad2.connect();
            });
            wait(1, function() {
              return _this._createEvent('on', pad2);
            });
          } else {
            gamepad.connected = false;
          }
          return _this.length - 1;
        };
      })(this);
      if (!(gamepad.id in this.registred)) {
        return add();
      } else {
        _ref = this.registred[gamepad.id];
        for (_i = 0, _len = _ref.length; _i < _len; _i++) {
          pad = _ref[_i];
          if (pad.gamepad.connected === false) {
            pad.gamepad = gamepad;
            if (gamepad.connected) {
              wait(0, function() {
                return pad.connect();
              });
              wait(1, (function(_this) {
                return function() {
                  return _this._createEvent('on', pad);
                };
              })(this));
            }
            return this.indexOf(pad);
          }
        }
        return add();
      }
      return -1;
    };


    /**
     * Механизм отключения джойстика.
     * @protected
     * @param Gamepad gamepad
     * @return void
     */

    Gamepads.prototype._gamepadDisconnect = function(gamepad) {
      var ids, pad, pad2, _i, _len;
      ids = this.registred[gamepad.id];
      if (!ids) {
        throwError("Gamepads: Disconect unregistered gamepad. After init should be call `detect` method.");
        return;
      }
      for (_i = 0, _len = ids.length; _i < _len; _i++) {
        pad = ids[_i];
        if (pad.gamepad === gamepad) {
          pad2 = pad;
          break;
        }
      }
      if (pad2 == null) {
        throwError("Gamepads: Critical: registred and not created gamepad!");
        return;
      }
      pad2.disconnect();
      this._createEvent('off', pad2);
    };


    /**
     * Запуск механизмаопроса состояний джойстиков.
     * @protected
     * @param Number Hz частота обновлений состояний
     * @param Number wHz частота опроса заданий webkit
     * @return void
     */

    Gamepads.prototype._startShedule = function(Hz, wHz) {
      var requestAnimationFrame;
      if (Hz == null) {
        Hz = 60;
      }
      if (wHz == null) {
        wHz = 10;
      }
      requestAnimationFrame = top.requestAnimationFrame || top.mozRequestAnimationFrame || top.webkitRequestAnimationFrame;
      requestAnimationFrame((function(_this) {
        return function() {
          var p, startTimers, stopTimers, t, ws;
          t = null;
          p = _this;
          ws = _webkitStyle;
          startTimers = function() {
            t === null && (t = tick(1000 / Hz | 0, function() {
              var pad, _i, _len;
              if ('webkitGetGamepads' in navigator) {
                navigator.webkitGetGamepads();
              }
              for (_i = 0, _len = p.length; _i < _len; _i++) {
                pad = p[_i];
                if (pad.connected) {
                  pad.poke();
                }
              }
            }));
            if (ws && _webkitPoolSheduller === null) {
              _webkitPoolSheduller = tick(1000 / wHz | 0, function() {
                var fn, _i, _len;
                for (_i = 0, _len = _reQueue.length; _i < _len; _i++) {
                  fn = _reQueue[_i];
                  fn();
                }
              });
            }
          };
          stopTimers = function() {
            if (t !== null) {
              stopTick(t);
              t = null;
            }
            if (_webkitPoolSheduller !== null && ws) {
              stopTick(_webkitPoolSheduller);
              _webkitPoolSheduller = null;
            }
          };
          top.addEventListener('focus', function() {
            return startTimers();
          });
          top.addEventListener('blur', function() {
            return stopTimers();
          });
          startTimers();
        };
      })(this));
    };

    Gamepads.getInfo = function(type) {
      if (type == null) {
        return {
          info: ["Gamepads: look at console logs!"]
        };
      }
      return ["Gamepads: look at console logs!"];
    };


    /**
     * Получаем сообщения системы.
     * @param String type
     * @return Array messages
     */

    Gamepads.getInfo = function(type) {
      if (type != null) {
        if (messages[type] != null) {
          return messages[type];
        }
        throwWarn("Gamepads: type message not exists: " + type);
      }
      return messages;
    };

    return Gamepads;

  })(EventedArray);

  this.Gamepads = Gamepads;

  this.Gamepad2 = Gamepad2;

  this.GamepadMap = GamepadMap;

}).call(this);
