// Generated by CoffeeScript 1.7.1
(function() {
  "use strict";

  /*
    naming variables:
    gamepad and gamepadX instance of Gamepad (by browser)
    pad and padX instance of Gamepad2 (local)
   */
  var Axis, Block, Button, EventTargetEmiter, EventedArray, Gamepad2, GamepadMap, Gamepads, SPoke, isFunction, isString, merge, messages, overlay, skip, start, stopTick, throwError, throwInfo, throwWarn, tick, top, wait, _implements,
    __slice = [].slice,
    __hasProp = {}.hasOwnProperty,
    __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
    __indexOf = [].indexOf || function(item) { for (var i = 0, l = this.length; i < l; i++) { if (i in this && this[i] === item) return i; } return -1; };

  _implements = function() {
    var key, mixin, mixins, value, _i, _len, _ref;
    mixins = 1 <= arguments.length ? __slice.call(arguments, 0) : [];
    for (_i = 0, _len = mixins.length; _i < _len; _i++) {
      mixin = mixins[_i];
      _ref = mixin.prototype;
      for (key in _ref) {
        value = _ref[key];
        this.prototype[key] = value;
      }
    }
    return this;
  };


  /**
    * накладывает объект `from` на объект `to`<br />
    * если нужно создать третий объект (не трогать `to`) из двух надо использовать `merge(merge({}, to), from)` <br />
    * (!) Нет защиты от дурака. Если аргументы не объекты, то результат не предсказуем и может быть ошибка.
    *
    * @method merge
    * @param {Object|Array} to модифицируемый объект
    * @param {Object|Array} from модифицирующий объект
    * @return {Object} изменённый `to`
   */

  merge = function(to, from) {
    var e, p;
    for (p in from) {
      if (!__hasProp.call(from, p)) continue;
      try {
        if (typeof from[p] === 'object') {
          to[p] = merge(to[p], from[p]);
        } else {
          to[p] = from[p];
        }
      } catch (_error) {
        e = _error;
        to[p] = merge({}, from[p]);
      }
    }
    return to;
  };


  /**
    * merge under with upper, but create new object, don't touch under or upper.
    *
    * @method overlay
    * @param {Object|Array} under basic object
    * @param {Object|Array} upper object width modification
    * @return {Object} new object
   */

  overlay = function(under, upper) {
    return merge(merge({}, under), upper);
  };

  messages = {
    error: [],
    warn: [],
    info: []
  };

  start = Date.now();

  throwError = function() {
    var errors, out;
    errors = 1 <= arguments.length ? __slice.call(arguments, 0) : [];
    out = [Date.now() - start];
    out.push.apply(out, errors);
    messages.error.push(out);
  };

  throwWarn = function() {
    var out, warn;
    warn = 1 <= arguments.length ? __slice.call(arguments, 0) : [];
    out = [Date.now() - start];
    out.push.apply(out, warn);
    messages.warn.push(out);
  };

  throwInfo = function() {
    var info, out;
    info = 1 <= arguments.length ? __slice.call(arguments, 0) : [];
    out = [Date.now() - start];
    out.push.apply(out, info);
    messages.info.push(out);
  };

  isFunction = function(functionToCheck) {
    var getType;
    getType = {};
    return functionToCheck && getType.toString.call(functionToCheck) === "[object Function]";
  };

  isString = function(string) {
    return string + '' === string;
  };

  wait = function(time, fn) {
    return setTimeout(fn, time);
  };

  skip = function(waitId) {
    return clearTimeout(waitId);
  };

  tick = function(time, fn) {
    return setInterval(fn, time);
  };

  stopTick = function(tickId) {
    return clearInterval(tickId);
  };

  EventTargetEmiter = (function() {
    EventTargetEmiter.prototype._subscribe = null;

    EventTargetEmiter.prototype._checkValues = function(type, listener) {
      if (!isString(type)) {
        throwError("type not string");
        return false;
      }
      if (!isFunction(listener)) {
        throwError("listener is not a function");
        return false;
      }
      return true;
    };

    function EventTargetEmiter() {
      var e, list, _i, _len;
      list = 1 <= arguments.length ? __slice.call(arguments, 0) : [];
      this._subscribe = {
        _length: 0
      };
      for (_i = 0, _len = list.length; _i < _len; _i++) {
        e = list[_i];
        this._subscribe[e] = [];
        this['on' + e] = null;
      }
    }

    EventTargetEmiter.prototype.addEventListener = function(type, listener, useCapture) {
      if (useCapture == null) {
        useCapture = false;
      }
      if (!this._checkValues(type, listener)) {
        return;
      }
      useCapture = !!useCapture;
      this._subscribe[type].push([listener, useCapture]);
      this._subscribe._length++;
    };

    EventTargetEmiter.prototype.removeEventListener = function(type, listener, useCapture) {
      var fn, i, _i, _len, _ref;
      if (useCapture == null) {
        useCapture = false;
      }
      if (!this._checkValues(type, listener)) {
        return;
      }
      useCapture = !!useCapture;
      if (this._subscribe[type] == null) {
        return;
      }
      _ref = this._subscribe[type];
      for (i = _i = 0, _len = _ref.length; _i < _len; i = ++_i) {
        fn = _ref[i];
        if (fn[0] === listener && fn[1] === useCapture) {
          this._subscribe[type].splice(i, 1);
          this._subscribe._length--;
          return;
        }
      }
    };

    EventTargetEmiter.prototype.dispatchEvent = function(evt) {
      var t;
      if (!(evt instanceof Event)) {
        throwError("evt is not event.");
        return false;
      }
      t = evt.type;
      if (this._subscribe[t] == null) {
        throw new EventException("UNSPECIFIED_EVENT_TYPE_ERR");
        return false;
      }
      return emet(t, evt);
    };

    EventTargetEmiter.prototype.on = EventTargetEmiter.prototype.addEventListener;

    EventTargetEmiter.prototype.off = EventTargetEmiter.prototype.removeEventListener;

    EventTargetEmiter.prototype.emet = function(name, evt) {
      var fn, r, _i, _len, _ref;
      if (evt == null) {
        evt = null;
      }
      if (isFunction(this['on' + name])) {
        r = this['on' + name](evt);
      }
      if (r === false) {
        return false;
      }
      _ref = this._subscribe[name];
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        fn = _ref[_i];
        try {
          r = fn[0](evt);
        } catch (_error) {}
        if (fn[1] === true || r === false) {
          break;
        }
      }
      if (evt != null) {
        return !evt.defaultPrevented;
      } else {
        return true;
      }
    };

    return EventTargetEmiter;

  })();

  EventedArray = (function(_super) {
    __extends(EventedArray, _super);

    _implements.call(EventedArray, EventTargetEmiter);

    function EventedArray() {
      var items;
      items = 1 <= arguments.length ? __slice.call(arguments, 0) : [];
      this.splice.apply(this, [0, 0].concat(__slice.call(items)));
    }

    return EventedArray;

  })(Array);

  EventTargetEmiter = (function() {
    EventTargetEmiter.prototype._subscribe = null;

    EventTargetEmiter.prototype._checkValues = function(type, listener) {
      if (!isString(type)) {
        throwError("type not string");
        return false;
      }
      if (!isFunction(listener)) {
        throwError("listener is not a function");
        return false;
      }
      return true;
    };

    function EventTargetEmiter() {
      var e, list, _i, _len;
      list = 1 <= arguments.length ? __slice.call(arguments, 0) : [];
      this._subscribe = {
        _length: 0
      };
      for (_i = 0, _len = list.length; _i < _len; _i++) {
        e = list[_i];
        this._subscribe[e] = [];
        this['on' + e] = null;
      }
    }

    EventTargetEmiter.prototype.addEventListener = function(type, listener, useCapture) {
      if (useCapture == null) {
        useCapture = false;
      }
      if (!this._checkValues(type, listener)) {
        return;
      }
      useCapture = !!useCapture;
      this._subscribe[type].push([listener, useCapture]);
      this._subscribe._length++;
    };

    EventTargetEmiter.prototype.removeEventListener = function(type, listener, useCapture) {
      var fn, i, _i, _len, _ref;
      if (useCapture == null) {
        useCapture = false;
      }
      if (!this._checkValues(type, listener)) {
        return;
      }
      useCapture = !!useCapture;
      if (this._subscribe[type] == null) {
        return;
      }
      _ref = this._subscribe[type];
      for (i = _i = 0, _len = _ref.length; _i < _len; i = ++_i) {
        fn = _ref[i];
        if (fn[0] === listener && fn[1] === useCapture) {
          this._subscribe[type].splice(i, 1);
          this._subscribe._length--;
          return;
        }
      }
    };

    EventTargetEmiter.prototype.dispatchEvent = function(evt) {
      var t;
      if (!(evt instanceof Event)) {
        throwError("evt is not event.");
        return false;
      }
      t = evt.type;
      if (this._subscribe[t] == null) {
        throw new EventException("UNSPECIFIED_EVENT_TYPE_ERR");
        return false;
      }
      return emet(t, evt);
    };

    EventTargetEmiter.prototype.on = EventTargetEmiter.prototype.addEventListener;

    EventTargetEmiter.prototype.off = EventTargetEmiter.prototype.removeEventListener;

    EventTargetEmiter.prototype.emet = function(name, evt) {
      var fn, r, _i, _len, _ref;
      if (evt == null) {
        evt = null;
      }
      if (isFunction(this['on' + name])) {
        r = this['on' + name](evt);
      }
      if (r === false) {
        return false;
      }
      _ref = this._subscribe[name];
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        fn = _ref[_i];
        try {
          r = fn[0](evt);
        } catch (_error) {}
        if (fn[1] === true || r === false) {
          break;
        }
      }
      if (evt != null) {
        return !evt.defaultPrevented;
      } else {
        return true;
      }
    };

    return EventTargetEmiter;

  })();

  SPoke = (function() {
    function SPoke() {}

    SPoke.prototype.s = function(action) {
      return this._subscribe.hasOwnProperty(action) && this._subscribe[action].length > 0;
    };

    SPoke.prototype.poke = function() {};

    return SPoke;

  })();

  this.GAMEPAD_AXIS_AS_STICK = 1;

  this.GAMEPAD_AXIS_AS_BUTTON = 2;

  this.GAMEPAD_AXIS_AS_COMBINED = 3;

  Axis = (function(_super) {
    __extends(Axis, _super);

    _implements.call(Axis, SPoke);

    Axis.prototype.MODE = 1;

    Axis.prototype.pressed = false;

    Axis.prototype.value = 0;

    Axis.prototype._oldValue = 0;

    Axis.prototype._oldPressed = false;

    function Axis(gamepad, num, mode, positive, triggerValue) {
      var r, _value;
      if (triggerValue == null) {
        triggerValue = 127;
      }
      this.MODE = mode;
      r = Math.round;
      if (mode === 1) {
        Axis.__super__.constructor.call(this, 'change');
        _value = function() {
          return r(gamepad.axes[num] * 255);
        };
      } else if (mode === 2) {
        Axis.__super__.constructor.call(this, 'change', 'press', 'down', 'up');
        _value = function() {
          if (positive) {
            return r(gamepad.axes[num] * 255) > triggerValue;
          } else {
            return r(gamepad.axes[num] * 255) < -triggerValue;
          }
        };
        this._oldPressed = _value();
      } else if (mode === 3) {
        Axis.__super__.constructor.call(this, 'change', 'press', 'down', 'up');
        _value = function(press) {
          if (press) {
            if (positive) {
              return (gamepad.axes[num] * 255) > triggerValue;
            } else {
              return (gamepad.axes[num] * 255) < -triggerValue;
            }
          }
          return r(gamepad.axes[num] * 255);
        };
        this._oldPressed = _value(true);
      } else {
        throwError("Axis mode not correct.");
      }
      this._oldValue = _value();
      Object.defineProperty(this, 'value', {
        get: function() {
          return _value();
        },
        set: (function(_this) {
          return function(v) {
            _this._oldValue = v;
          };
        })(this)
      });
      Object.defineProperty(this, 'pressed', {
        get: function() {
          return mode !== 1 && _value(true);
        },
        set: (function(_this) {
          return function(v) {
            if (mode !== 1) {
              _this._oldPressed = v;
            }
          };
        })(this)
      });
      this.reSubscribe = function(gamepadNew) {
        gamepad = gamepadNew;
      };
    }

    Axis.prototype.poke = function() {
      var p, v;
      if (this._subscribe._length > 0) {
        if (this.s('change')) {
          if (this._oldValue !== (v = this.value)) {
            this.emet('change', new CustomEvent('change', {
              detail: {
                oldValue: this._oldValue,
                newValue: v
              }
            }));
          }
        }
        if (this.MODE === 2 || this.MODE === 3) {
          if (this.s('press') || this.s('down') || this.s('up')) {
            if ((p = this.pressed) !== this._oldPressed) {
              if (p) {
                if (this.s("down")) {
                  this.emet('down');
                }
              } else {
                if (this.s("up")) {
                  this.emet("up");
                }
                if (this.s("press")) {
                  this.emet('press');
                }
              }
              this.pressed = p;
            }
          }
        }
        if (v != null) {
          this._oldValue = v;
        }
      }
    };

    Axis.prototype.reSubscribe = function(gamepadNew) {};

    return Axis;

  })(EventTargetEmiter);

  Button = (function(_super) {
    __extends(Button, _super);

    _implements.call(Button, SPoke);

    Button.prototype.pressed = false;

    Button.prototype._oldPressed = false;

    function Button(gamepad, num) {
      var _value;
      if (typeof gamepad !== "object") {
        throwError("gamepad is not Gamepad");
        return;
      }
      if (!isFinite(num)) {
        throwError("num of button not number");
        return;
      }
      num = num | 0;
      if (num < 0) {
        throwError("Index button less than 0");
        return;
      }
      if (gamepad.buttons[num] == null) {
        throwError("Button: button " + num + " not exists");
        return;
      }
      Button.__super__.constructor.call(this, 'change', 'press', 'down', 'up');
      if (isFinite(gamepad.buttons[0])) {
        _value = function() {
          return gamepad.buttons[num] > 0.5;
        };
      } else {
        _value = function() {
          return gamepad.buttons[num].pressed;
        };
      }
      Object.defineProperty(this, 'pressed', {
        get: function() {
          return _value();
        },
        set: (function(_this) {
          return function(v) {
            _this._oldPressed = v;
          };
        })(this)
      });
      this.reSubscribe = function(gamepadNew) {
        return gamepad = gamepadNew;
      };
    }

    Button.prototype.poke = function() {
      var p;
      if (this._subscribe._length > 0) {
        if (this._oldPressed !== (p = this.pressed)) {
          if (this.s("change")) {
            this.emet("change", new CustomEvent('change', {
              detail: {
                oldValue: !p,
                newValue: p
              }
            }));
          }
          if (p) {
            if (this.s("down")) {
              this.emet("down");
            }
          } else {
            if (this.s("up")) {
              this.emet("up");
            }
            if (this.s("press")) {
              this.emet("press");
            }
          }
          return this.pressed = p;
        }
      }
    };

    Button.prototype.reSubscribe = function(gamepadNew) {};

    return Button;

  })(EventTargetEmiter);

  Block = (function(_super) {
    __extends(Block, _super);

    _implements.call(Block, SPoke);

    Block.prototype.gamepad = null;

    Block.prototype.map = null;

    function Block(map, gamepad) {
      EventTargetEmiter.call(this, 'change');
      this.gamepad = gamepad;
      this._mapParse(map);
    }

    Block.prototype._mapParse = function(map) {
      var axis, button, name, val;
      this.map = map;
      for (name in map) {
        if (!__hasProp.call(map, name)) continue;
        val = map[name];
        if (val.hasOwnProperty('axis') && (val.axis != null)) {
          axis = new Axis(this.gamepad, val.axis, val.mode || AS_STICK, Boolean(val.positive), val.triggerValue || 0);
          if ('onchange' in axis) {
            this[name] = axis;
          } else {
            delete map[name];
            continue;
          }
        } else if (val.hasOwnProperty('button') && (val.button != null)) {
          button = new Button(this.gamepad, val.button);
          if ('onchange' in button) {
            this[name] = button;
          } else {
            delete map[name];
            continue;
          }
        } else {
          throwError("Value " + name + " of MAP incorrect!");
          return;
        }
        this[name].on('change', (function(_this) {
          return function(e) {
            _this.emet('change', e);
          };
        })(this));
      }
    };

    Block.prototype.addEventListener = function(type) {
      var name, _ref;
      if (type === 'change' && !this.s('change')) {
        _ref = this.map;
        for (name in _ref) {
          if (!__hasProp.call(_ref, name)) continue;
          this[name].on('change', (function(_this) {
            return function(e) {
              _this.emet('change', e);
            };
          })(this));
        }
      }
      return Block.__super__.addEventListener.apply(this, arguments);
    };

    Block.prototype.reSubscribe = function(gamepad) {
      var name, val, _ref;
      this.gamepad = gamepad;
      _ref = this.map;
      for (name in _ref) {
        if (!__hasProp.call(_ref, name)) continue;
        val = _ref[name];
        if (this[name] == null) {
          continue;
        }
        if (val.hasOwnProperty('axis')) {
          this[name].reSubscribe(gamepad);
        } else if (val.hasOwnProperty('button')) {
          this[name].reSubscribe(gamepad);
        } else {
          throwError("Map was be changed or crashed");
        }
      }
    };

    Block.prototype.poke = function() {
      var name, _ref;
      _ref = this.map;
      for (name in _ref) {
        if (!__hasProp.call(_ref, name)) continue;
        this[name].poke();
      }
    };

    return Block;

  })(EventedArray);

  GamepadMap = (function() {
    GamepadMap.prototype.vendor = "";

    GamepadMap.prototype.product = "";

    GamepadMap.prototype.platform = "linux";

    GamepadMap.prototype.activeMap = null;

    function GamepadMap(vendor, product) {
      var isLinux, isMac, isWindows, platform;
      if (!(isString(vendor) && vendor.length === 4 && /[a-f0-9]/i.test(vendor))) {
        throwError("GamepadMap: vendor incorrect: " + vendor);
        return;
      }
      if (!(isString(product) && product.length === 4 && /[a-f0-9]/i.test(product))) {
        throwError("GamepadMap: product incorrect: " + product);
        return;
      }
      this.vendor = vendor.toLowerCase();
      this.product = product.toLowerCase();
      isLinux = /linux/i;
      isMac = /mac/i;
      isWindows = /window/i;
      platform = navigator.platform;
      if (isLinux.test(platform)) {
        this.platform = "linux";
      } else if (isMac.test(platform)) {
        this.platform = "mac";
      } else if (isWindows.test(platform)) {
        this.platform = "windows";
      } else {
        throwWarn("Mobile or other not supported platform");
        this.platform = "other";
      }
      this.activeMap = this.loadMap();
    }

    GamepadMap.prototype.loadMap = function() {
      var defaultMap, index, map, mapsByPlatform;
      index = this.vendor + this.product;
      if (!(isString(index) && index.length === 8 && /[a-f0-9]/.test(index))) {
        throwError("GamepadMap: in map changed vendor or product on incorrect");
        return;
      }
      defaultMap = this.other["00000000"];
      if (index === "00000000") {
        return defaultMap;
      }
      mapsByPlatform = this[this.platform];
      if (mapsByPlatform == null) {
        throwWarn("GamepadMap: platform not supported. Use default map.");
        return defaultMap;
      }
      if (!mapsByPlatform.hasOwnProperty(index)) {
        throwWarn("GamepadMap: vendor or product not supported. Use default map.");
        return defaultMap;
      }
      map = mapsByPlatform[index];
      if (isString(map)) {
        if (mapsByPlatform.hasOwnProperty(map)) {
          return overlay(defaultMap, mapsByPlatform[map]);
        }
        throwWarn("GamepadMap: index of map not avialable.");
        return defaultMap;
      }
      return overlay(defaultMap, map) || defaultMap;
    };

    GamepadMap.prototype.linux = {
      "045e028e": "XInputStyleGamepad",
      "045e028f": "XInputStyleGamepad",
      "046dc21d": "XInputStyleGamepad",
      "046dc21e": "XInputStyleGamepad",
      "046dc21f": "XInputStyleGamepad",
      "046dc216": "DirectInputStyle",
      "046dc218": "DirectInputStyle",
      "046dc219": "DirectInputStyle",
      "XInputStyleGamepad": {
        lrtb: {
          LT: {
            axis: 2,
            positive: true,
            mode: 3,
            triggerValue: 0
          },
          RT: {
            axis: 5,
            positive: true,
            mode: 3,
            triggerValue: 0
          }
        },
        menu: {
          back: {
            button: 6
          },
          start: {
            button: 7
          },
          home: {
            button: 8
          }
        },
        axes: {
          LSB: {
            button: 9
          },
          RSB: {
            button: 10
          },
          RSX: {
            axis: 3,
            mode: 1
          },
          RSY: {
            axis: 4,
            mode: 1
          }
        },
        dpad: {
          up: {
            axis: 7,
            positive: false,
            mode: 2
          },
          down: {
            axis: 7,
            positive: true,
            mode: 2
          },
          left: {
            axis: 6,
            positive: false,
            mode: 2
          },
          right: {
            axis: 6,
            positive: true,
            mode: 2
          }
        }
      },
      "DirectInputStyle": {
        face: {
          PR: {
            button: 1
          },
          SC: {
            button: 2
          },
          TR: {
            button: 0
          }
        },
        dpad: {
          up: {
            axis: 5,
            positive: false,
            mode: 2
          },
          down: {
            axis: 5,
            positive: true,
            mode: 2
          },
          left: {
            axis: 4,
            positive: false,
            mode: 2
          },
          right: {
            axis: 4,
            positive: true,
            mode: 2
          }
        }
      }
    };

    GamepadMap.prototype.other = {
      "example": {
        blockName: {
          buttonName: {
            button: 0,
            asAxis: false,
            axis: null
          },
          axisName: {
            axis: 0,
            mode: AS_COMBINED,
            positive: true,
            triggerValue: 127
          }
        }
      },
      "00000000": {
        face: {
          PR: {
            button: 0
          },
          SC: {
            button: 1
          },
          TR: {
            button: 2
          },
          QT: {
            button: 3
          }
        },
        lrtb: {
          LB: {
            button: 4
          },
          RB: {
            button: 5
          },
          LT: {
            button: 6,
            asAxis: true
          },
          RT: {
            button: 7,
            asAxis: true
          }
        },
        menu: {
          back: {
            button: 8
          },
          start: {
            button: 9
          },
          home: {
            button: 16
          },
          caca: {
            button: 17
          }
        },
        axes: {
          LSB: {
            button: 10
          },
          LSX: {
            axis: 0,
            mode: 1
          },
          LSY: {
            axis: 1,
            mode: 1
          },
          RSB: {
            button: 11
          },
          RSX: {
            axis: 2,
            mode: 1
          },
          RSY: {
            axis: 3,
            mode: 1
          }
        },
        dpad: {
          up: {
            button: 12
          },
          down: {
            button: 13
          },
          left: {
            button: 14
          },
          right: {
            button: 15
          }
        }
      }
    };

    return GamepadMap;

  })();

  Gamepad2 = (function(_super) {
    var _synonyms;

    __extends(Gamepad2, _super);

    Gamepad2.prototype.connected = false;

    Gamepad2.prototype.gamepad = null;

    Gamepad2.prototype.map = null;

    Gamepad2.prototype.axes = null;

    Gamepad2.prototype.dpad = null;

    Gamepad2.prototype.face = null;

    Gamepad2.prototype.lrtb = null;

    Gamepad2.prototype.menu = null;

    function Gamepad2(gamepad, config, map) {
      if (map == null) {
        map = null;
      }
      EventTargetEmiter.call(this, 'change', 'on', 'off');
      this.gamepad = gamepad;
      if (map != null) {
        this.map = map;
      } else if (gamepad.axes.length === 4) {
        this.map = new GamepadMap("0000", "0000");
      } else {
        this.getMap(gamepad.id);
      }
      this.axes = null;
      this.dpad = null;
      this.menu = null;
      this.face = null;
      this.lrtb = null;
    }

    Gamepad2.prototype.getMap = function(id) {
      var match, moz, other, webkit;
      moz = /([0-9a-f]{4})\-([0-9a-f]{4})\-[\s\w]+/;
      webkit = /Vendor: ([0-9a-f]{4}) Product: ([0-9a-f]{4})/;
      other = /\b([0-9a-f]{4})\b.+\b([0-9a-f]{4})\b/;
      if (moz.test(id)) {
        match = id.match(moz);
      } else if (webkit.test(id)) {
        match = id.match(webkit);
      } else if (other.test(id)) {
        match = id.match(other);
      } else {
        match = [null, "0000", "0000"];
      }
      return this.map = new GamepadMap(match[1], match[2]);
    };

    Gamepad2.prototype.connect = function() {
      var aMap, block, blockName;
      aMap = this.map.activeMap;
      for (blockName in aMap) {
        if (!__hasProp.call(aMap, blockName)) continue;
        block = aMap[blockName];
        if (this.hasOwnProperty(blockName)) {
          if (this[blockName] === null) {
            this[blockName] = new Block(block, this.gamepad);
          } else {
            this[blockName].reSubscribe(this.gamepad);
          }
        }
      }
      this.connected = true;
      this.emet("on");
    };

    Gamepad2.prototype.disconnect = function() {
      this.connected = false;
      this.emet("off");
    };

    Gamepad2.prototype.poke = function() {
      var block, _ref;
      if (!this.connected) {
        return;
      }
      _ref = this.map.activeMap;
      for (block in _ref) {
        if (!__hasProp.call(_ref, block)) continue;
        this[block].poke();
      }
    };

    _synonyms = [["PR", "primary"], ["SC", "secondary"], ["TR", "tertiary"], ["QT", "quaternary"], ["lrtb", "shouldersTriggers"], ["dpad", "dPad"], ["LB", "leftShoulder"], ["RB", "rightShoulder"], ["LT", "leftTrigger"], ["RT", "rightTrigger"], ["LSB", "leftStickButton"], ["RSB", "rightStickButton"]];

    return Gamepad2;

  })(EventTargetEmiter);

  top = this;

  this.GAMEPAD_NAME_FULL = 1;

  this.GAMEPAD_NAME_SHORT = 2;

  Gamepads = (function(_super) {
    var defaultConfig, _reQueue, _support, _webkitPoolSheduller, _webkitStyle;

    __extends(Gamepads, _super);

    _support = false;

    _webkitStyle = false;

    _webkitPoolSheduller = null;

    _reQueue = [];

    defaultConfig = {
      silent: true,
      frequencyUpdate: 60,
      webkitFrequencyUpdate: 10,
      naming: 1
    };

    function Gamepads(config) {
      var _getPad, _registered;
      if (config == null) {
        config = {};
      }
      if (typeof navigator === "undefined" || navigator === null) {
        throwError("Gamepads: navigator not exists! Browser strange.");
        return;
      }
      if ((navigator.getGamepads == null) && (navigator.webkitGetGamepads == null)) {
        throwError("Gamepads: Gamepad API not yet.");
        return;
      }
      EventTargetEmiter.call(this, 'on', 'off', 'add');
      this.config = merge(defaultConfig, config);
      if (navigator.getGamepads != null) {
        top.addEventListener('gamepadconnected', (function(_this) {
          return function(e) {
            var r;
            r = _this._addGamepad(e.gamepad);
            if (r === -1) {
              r = _this.registred[e.gamepad.id];
              if (r == null) {
                throwError("Gamepads: gamepad not added!");
                return;
              }
            }
            _this._createEvent('on', _this[r]);
          };
        })(this));
        top.addEventListener('gamepaddisconnected', (function(_this) {
          return function(e) {
            return _this._gamepadDisconnect(e.gamepad);
          };
        })(this));
      } else {
        _webkitStyle = true;
        _registered = [];
        _getPad = (function(_this) {
          return function(gamepad) {
            var pad, _i, _len, _ref;
            _ref = _this.registred[gamepad.id];
            for (_i = 0, _len = _ref.length; _i < _len; _i++) {
              pad = _ref[_i];
              if (gamepad === pad.gamepad) {
                return pad;
              }
            }
            return null;
          };
        })(this);

        /*_webkitStyle.detail =
          instance: @
          registered: _registered
         */
        _reQueue.push((function(_this) {
          return function() {
            var gamepad, r2, _i, _len, _ref;
            _ref = navigator.webkitGetGamepads();
            for (_i = 0, _len = _ref.length; _i < _len; _i++) {
              gamepad = _ref[_i];
              if (!gamepad) {
                continue;
              }
              if (__indexOf.call(_registered, gamepad) < 0) {
                _registered.push(gamepad);
                r2 = _this._addGamepad(gamepad);
                if (!gamepad.hasOwnProperty('connected')) {
                  gamepad.connected = false;
                  gamepad.timechange = Date.now() - 15 * 60000;
                } else {
                  if (gamepad.connected === true) {
                    _this[r2].connect();
                    _this._createEvent('on', _this[r2]);
                  }
                }
              }
            }
          };
        })(this));
        _reQueue.push((function(_this) {
          return function() {
            var button, gamepad, pad3, pressedButton, _i, _j, _len, _len1, _ref;
            for (_i = 0, _len = _registered.length; _i < _len; _i++) {
              gamepad = _registered[_i];
              if (gamepad.connected) {
                if (Date.now() - gamepad.timechange > 15 * 60000) {
                  gamepad.connected = false;
                  _this._gamepadDisconnect(gamepad);
                }
              } else if (Date.now() - gamepad.timechange < 15 * 60000) {
                gamepad.connected = true;
                pad3 = _getPad(gamepad);
                if (!pad3) {
                  throwError("Gamepads: gamepad registered not created or replaced");
                  return;
                }
                pad3.connect();
                _this._createEvent('on', pad3);
              } else {
                pressedButton = false;
                _ref = gamepad.buttons;
                for (_j = 0, _len1 = _ref.length; _j < _len1; _j++) {
                  button = _ref[_j];
                  if (button) {
                    pressedButton = true;
                    break;
                  }
                }
                if (pressedButton) {
                  gamepad.timechange = Date.now();
                }
              }
            }
          };
        })(this));
      }
      navigator.getGamepads = navigator.getGamepads || navigator.webkitGetGamepads;
      this._startShedule();
      this.registred = {};
      _support = true;
    }

    Gamepads.prototype.registred = null;

    Gamepads.prototype.config = null;

    Gamepads.prototype.detect = function() {
      var gamepad, _i, _len, _ref;
      if (!_support) {
        return false;
      }
      _ref = navigator.getGamepads();
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        gamepad = _ref[_i];
        this._addGamepad(gamepad);
      }
      return true;
    };

    Gamepads.prototype._createEvent = function(name, gamepad) {
      if (!isString(name)) {
        return null;
      }
      if (!gamepad) {
        return null;
      }
      return this.emet(name, new CustomEvent(name, {
        detail: gamepad
      }));
    };

    Gamepads.prototype._addGamepad = function(gamepad) {
      var add, pad, _i, _len, _ref;
      if (gamepad == null) {
        return -2;
      }
      add = (function(_this) {
        return function() {
          var pad2;
          pad2 = new Gamepad2(gamepad);
          if (_webkitStyle) {
            pad2.on("change", function() {
              return gamepad.timechange = Date.now();
            });
          }
          _this.push(pad2);
          _this.registred[gamepad.id] = [pad2];
          _this._createEvent('add', pad2);
          if (gamepad.connected) {
            pad2.connect();
          } else {
            gamepad.connected = false;
          }
          return _this.length - 1;
        };
      })(this);
      if (!(gamepad.id in this.registred)) {
        return add();
      } else {
        _ref = this.registred[gamepad.id];
        for (_i = 0, _len = _ref.length; _i < _len; _i++) {
          pad = _ref[_i];
          if (pad.gamepad.connected === false) {
            pad.gamepad = gamepad;
            if (gamepad.connected) {
              pad.connect();
            }
            return this.indexOf(pad);
          }
        }
        return add();
      }
      return -1;
    };

    Gamepads.prototype._gamepadDisconnect = function(gamepad) {
      var ids, pad, pad2, _i, _len;
      ids = this.registred[gamepad.id];
      if (!ids) {
        throwError("Gamepads: Disconect unregistered gamepad. After init should be call `detect` method.");
        return;
      }
      for (_i = 0, _len = ids.length; _i < _len; _i++) {
        pad = ids[_i];
        if (pad.gamepad === gamepad) {
          pad2 = pad;
          break;
        }
      }
      if (pad2 == null) {
        throwError("Gamepads: Critical: registred and not created gamepad!");
        return;
      }
      pad2.disconnect();
      this._createEvent('off', pad2);
    };

    Gamepads.prototype._startShedule = function(Hz) {
      var requestAnimationFrame;
      if (Hz == null) {
        Hz = 60;
      }
      requestAnimationFrame = top.requestAnimationFrame || top.mozRequestAnimationFrame || top.webkitRequestAnimationFrame;
      requestAnimationFrame((function(_this) {
        return function() {
          var p, startTimers, stopTimers, t;
          t = null;
          p = _this;
          startTimers = function() {
            t === null && (t = tick(1000 / Hz | 0, function() {
              var pad, _i, _len;
              for (_i = 0, _len = p.length; _i < _len; _i++) {
                pad = p[_i];
                if (pad.connected) {
                  pad.poke();
                }
              }
            }));
            if (_webkitStyle && _webkitPoolSheduller === null) {
              _webkitPoolSheduller = tick(100, function() {
                var fn, _i, _len;
                for (_i = 0, _len = _reQueue.length; _i < _len; _i++) {
                  fn = _reQueue[_i];
                  fn();
                }
              });
            }
          };
          stopTimers = function() {
            if (t !== null) {
              stopTick(t);
              t = null;
            }
            if (_webkitPoolSheduller !== null && _webkitStyle) {
              stopTick(_webkitPoolSheduller);
              _webkitPoolSheduller = null;
            }
          };
          top.addEventListener('focus', function() {
            return startTimers();
          });
          top.addEventListener('blur', function() {
            return stopTimers();
          });
          startTimers();
        };
      })(this));
    };

    Gamepads.getInfo = function(type) {
      if (type != null) {
        if (messages[type] != null) {
          return messages[type];
        }
        throwWarn("Gamepads: type message not exists: " + type);
      }
      return messages;
    };

    return Gamepads;

  })(EventedArray);

  this.Gamepads = Gamepads;

  this.Gamepad2 = Gamepad2;

  this.GamepadMap = GamepadMap;

}).call(this);
